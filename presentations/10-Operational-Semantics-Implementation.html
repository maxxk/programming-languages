<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>10-Operational-Semantics-Implementation</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;" id="container">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator" id="main">
   <a id="slider-default"></a>
   <label title="Flat view" id="flat-view"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="mechanized-semantics">Mechanized semantics</h2>
<h3 id="compcert-verified-c-compiler">CompCert verified C compiler</h3>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: small !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
.inference table {
    display: inline-block;
    padding: 1em;
}
.slider > section pre {
  line-height: 1.5 !important;
}

section ol li, section ul li {
  line-height: 1.5 !important;
}

.inference table th {
    font-weight: normal;
    border-bottom: 2px solid black;
}
.ib {
    display: inline-block;
}

</style>
<p><a href="https://maxxk.github.io/programming-languages/" class="uri">https://maxxk.github.io/programming-languages/</a></p>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#mechanized-semantics-for-the-clight-subset-of-the-c-language"></a></div>
<section id="mechanized-semantics-for-the-clight-subset-of-the-c-language" class="slide level1">
<h1>Mechanized Semantics for the Clight Subset of the C Language</h1>
<p>Big-step operational semantics for a subset of the C programming language. Implemented in Coq for CompCert certifying C compiler.</p>
<p>Links:</p>
<ol type="1">
<li class="fragment">Official site: <a href="http://compcert.inria.fr/" class="uri">http://compcert.inria.fr/</a></li>
<li class="fragment">Source code repository: <a href="https://github.com/AbsInt/CompCert" class="uri">https://github.com/AbsInt/CompCert</a> (non-free software, see license: <a href="https://github.com/AbsInt/CompCert/blob/master/LICENSE" class="uri">https://github.com/AbsInt/CompCert/blob/master/LICENSE</a>)</li>
<li class="fragment">Complete commented (literate) Coq source code: <a href="http://compcert.inria.fr/doc/index.html" class="uri">http://compcert.inria.fr/doc/index.html</a></li>
<li class="fragment">Full source code for the article: <a href="http://compcert.inria.fr/doc/html/compcert.cfrontend.Clight.html" class="uri">http://compcert.inria.fr/doc/html/compcert.cfrontend.Clight.html</a></li>
</ol>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#bibliography"></a></div>
<section id="bibliography" class="slide level1">
<h1>Bibliography</h1>
<ol type="1">
<li class="fragment">Jourdan J.-H., Leroy X., Pottier F. Validating LR(1) Parsers // Proceedings of the 21st European Symposium on Programming. 2012. Vol. 7211. P. 397–416.</li>
<li class="fragment">Blazy R., Dargaye Z., Leroy X. Formal Verification of a C Compiler Front-End // FM 2006: Formal Methods. Springer Berlin Heidelberg, 2006. P. 460–475.</li>
<li class="fragment">Leroy X. Formal Verification of a Realistic Compiler // Communications of the ACM. 2009. Vol. 52, № 7. P. 107–115.</li>
<li class="fragment">Boldo S. et al.&nbsp;Verified Compilation of Floating-Point Computations // Journal of Automated Reasoning. 2015. Vol. 54, № 2. P. 135–163.</li>
<li class="fragment">Blazy S., Leroy X. Mechanized Semantics for the Clight Subset of the C Language // Journal of Automated Reasoning. 2009. Vol. 43, № 3. P. 263–288.</li>
<li class="fragment">Leroy X. Formal Certification of a Compiler Back-end or: Programming a Compiler with a Proof Assistant // Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. New York, NY, USA: ACM, 2006. P. 42–54.</li>
<li class="fragment">Leroy X., Blazy S. Formal Verification of a C-like Memory Model and Its Uses for Verifying Program Transformations // J Autom Reasoning. 2008. Vol. 41, № 1. P. 1–31.</li>
</ol>
</section><div><a class="slider-prev" href="#mechanized-semantics-for-the-clight-subset-of-the-c-language"></a><a class="slider-next" href="#clight-language"></a></div>
<section id="clight-language" class="slide level1">
<h1>Clight language</h1>
<p>— intermediate representation of C programs (source code in C is desugared into Clight).</p>
<ul>
<li class="fragment">no concrete syntax (but for the sake of readability we sometimes will use C-like syntax)</li>
<li class="fragment">no string literals (replaced with pointers to static data section)</li>
<li class="fragment">all expressions are pure: assignment is a statement, increment/decrement operators are disabled etc. (behavior of some constructions, unspecified by the specification, is specified at the C → Clight translation stage, e.g.&nbsp;order of evaluation of function arguments)</li>
<li class="fragment">all expressions are annotated with types</li>
<li class="fragment">temporary variables are introduced</li>
<li class="fragment">function call is a statement with result assigned to temporary variable</li>
<li class="fragment"><code>for</code>, <code>while</code> and <code>do ... while</code> loops are desugared into a single construction <code>loop &lt;first&gt; &lt;next&gt;</code></li>
</ul>
</section><div><a class="slider-prev" href="#bibliography"></a><a class="slider-next" href="#clight-abstract-syntax"></a></div>
<section id="clight-abstract-syntax" class="slide level1">
<h1>Clight abstract syntax</h1>
<h2 id="expressions">Expressions</h2>
<pre><code>Inductive expr : Type :=
  (* integer literal, e.g. `1234` \*)
  | Econst_int : int → type → expr
  (* binary operation, e.g. `a+b` \*)
  | Ebinop : binary_operation → expr → expr → type → expr
  (* type cast, e.g. `(float)x` \*)
  | Ecast : expr → type → expr
  | …</code></pre>
</section><div><a class="slider-prev" href="#clight-language"></a><a class="slider-next" href="#clight-abstract-syntax-1"></a></div>
<section id="clight-abstract-syntax-1" class="slide level1">
<h1>Clight abstract syntax</h1>
<h2 id="statements">Statements</h2>
<pre><code>Inductive statement : Type :=
  (* do nothing \*)
  | Sskip : statement
  (* assignment `lvalue = rvalue`, lvalue may contain e.g. pointer arithmetics \*)
  | Sassign : expr → expr → statement
  (* desugared loop \*)
  | Sloop : statement → statement → statement
  | Sbreak : statement
  | Scontinue : statement
  | …</code></pre>
</section><div><a class="slider-prev" href="#clight-abstract-syntax"></a><a class="slider-next" href="#clight-loop-desugaring"></a></div>
<section id="clight-loop-desugaring" class="slide level1">
<h1>Clight loop desugaring</h1>
<pre><code>Definition Swhile (e: expr) (s: statement) :=
  Sloop (Ssequence (Sifthenelse e Sskip Sbreak) s) Sskip.

Definition Sdowhile (s: statement) (e: expr) :=
  Sloop s (Sifthenelse e Sskip Sbreak).

Definition Sfor (s1: statement) (e2: expr) (s3: statement) (s4: statement) :=
  Ssequence s1 (Sloop (Ssequence (Sifthenelse e2 Sskip Sbreak) s3) s4).</code></pre>
</section><div><a class="slider-prev" href="#clight-abstract-syntax-1"></a><a class="slider-next" href="#clight-static-semantics"></a></div>
<section id="clight-static-semantics" class="slide level1">
<h1>Clight static semantics</h1>
<h2 id="global-environment">Global environment</h2>
<p>G maps names of functions and global variables to memory block references, and function pointers to their definitions.</p>
<h2 id="local-and-temporary-environments">Local and temporary environments</h2>
<p>The local environment E maps local variables to memory block references with types. The temporary environemnt maps local temporaries to values.</p>
</section><div><a class="slider-prev" href="#clight-loop-desugaring"></a><a class="slider-next" href="#clight-operational-semantics-overview"></a></div>
<section id="clight-operational-semantics-overview" class="slide level1">
<h1>Clight operational semantics overview</h1>
<p>Big-step operational semantcs. 10 evaluation relations are defined:</p>
<ol type="1">
<li class="fragment">G, E ⊦ a, M ⇐ L — evaluation of expressions in l-value position, i.e.&nbsp;targets of assignment</li>
</ol>
<p>L is a location — pair of block identifier <em>b</em> and offset δ inside the block.</p>
<ol start="2" type="1">
<li class="fragment">G, E ⊦ a, M ⇒ v — evaluation of expressions in r-value position</li>
</ol>
<p>v is a value.</p>
<ol start="3" type="1">
<li class="fragment">G, E ⊦ [a], M ⇒ [v] — evaluation of lists of expression, e.g.&nbsp;function call arguments</li>
<li class="fragment">G, E ⊦ s, M ⇒ out, M’ — evaluation of statements, terminating case, M and M’ are memory states</li>
<li class="fragment">G, E ⊦ sw, M ⇒ out, M’ — execution of the <code>switch</code> cases</li>
<li class="fragment">G ⊦ Fd([v]), M ⇒ v, M’ — evaluation of function invocation, terminating case</li>
<li class="fragment">G, E ⊦ s, M ⇒ ∞ — evaluation of statements, diverging case</li>
</ol>
<p>8, 9. — diverging evaluation of <code>switch</code> cases and function invocation</p>
<ol start="10" type="1">
<li class="fragment">P ⇒ B — execution of the whole program</li>
</ol>
</section><div><a class="slider-prev" href="#clight-static-semantics"></a><a class="slider-next" href="#indexed-inductive-types"></a></div>
<section id="indexed-inductive-types" class="slide level1">
<h1>Indexed inductive types</h1>
<p>Simple inductive types — represented by a set of constructors, all values have same type (see expressions and statements above). Indexed inductive types — represented by a set of constructors and some index type. Each instance of indexed inductive type is a separate type. Example (from <a href="http://maxxk.github.io/formal-models-2015/pdf/08-Inductive.pdf">previous semester</a>):</p>
<pre><code>Even : ℕ → Type :=
| even_zero : Even 0
| even_plus_2 : forall (k : ℕ), Even(k) → Even(k+2)</code></pre>
<p><em>Even 0,</em> <em>Even 2</em> and <em>Even 4</em> are of different types (but <em>Even 2</em> and <em>Even 4</em> are constructed by call of the same constructor <em>even_plus_2</em>).</p>
</section><div><a class="slider-prev" href="#clight-operational-semantics-overview"></a><a class="slider-next" href="#evaluation-relations-in-dependently-typed-specification-language"></a></div>
<section id="evaluation-relations-in-dependently-typed-specification-language" class="slide level1">
<h1>Evaluation relations in dependently-typed specification language</h1>
<p>Evaluation relations are defined as an indexed inductive type. It is common way of definition for possibly-undecidable relations.</p>
<pre><code>Inductive eval_expr (G : global) (L : local) : expr → val → Type (* expr ⇒ val *)</code></pre>
<p>Two indices:</p>
<ul>
<li class="fragment"><em>expr</em> — left hand side of relation</li>
<li class="fragment"><em>val</em> — right hand side of relation</li>
</ul>
<p>Individual judgements are represented as the constructors for the indexed inductive type. Axiom:</p>
<pre><code>| eval_Econst_int : forall (i : int, ty : Ctype), eval_expr (Econst_int i ty) (Vint i)</code></pre>
<p>Same judgement in different notation:</p>
<p>G, E ⊦ <em>Econst_int</em> i ty ⇒ <em>Vint</em> i [<strong>eval_Econst_int</strong>]</p>
</section><div><a class="slider-prev" href="#indexed-inductive-types"></a><a class="slider-next" href="#evaluation-relations"></a></div>
<section id="evaluation-relations" class="slide level1 inference">
<h1 class="inference">Evaluation relations</h1>
<p>Premises (antecedents) are represented as a constructor arguments:</p>
<p>Rule:</p>
<pre><code>| eval_Ebinop : forall op a1 a2 ty v1 v2 v,
    eval_expr a1 v1 →
    eval_expr a2 v2 →
    sem_binary_op G op v1 (typeof a1) v2 (typeof a2) m = Some v →
    eval_expr (Ebinop op a1 a2 ty) v</code></pre>
<p>Different notation:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">a₁ ⇒ v₁; a₂ ⇒ v₂; v₁ <code>op</code> v₂ <span class="math inline">⇒<sub>binop</sub></span> v</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">[ty] a₁ <code>op</code> a₂ ⇒ v</td>
</tr>
</tbody>
</table>
<p><code>sem_binary_op</code> (binop) is a decidable relation, hence we may represent it as a function.</p>
</section><div><a class="slider-prev" href="#evaluation-relations-in-dependently-typed-specification-language"></a><a class="slider-next" href="#expression-evaluation-and-static-semantics"></a></div>
<section id="expression-evaluation-and-static-semantics" class="slide level1">
<h1>Expression evaluation and static semantics</h1>
<p>We have environments G and E as a parameters, so we can use them in premises of definition. <code>expr</code> — relation left hand side; <code>block, int</code> — right hand side (memory block and offset)</p>
<pre><code>Inductive eval_lvalue (E : local) (G : global): expr → block → int → Prop :=
| eval_Evar_local : forall id  l  ty,
    E ! id = Some(l, ty) →
    eval_lvalue (Evar id ty) l Int.zero
| eval_Evar_global : forall id l ty,
    E ! id = None →
    Genv.find_symbol G id = Some l →
    eval_lvalue (Evar id ty) l Int.zero
| …</code></pre>
<p>Note that both <code>eval_Evar_local</code> and <code>eval_Evar_global</code> have the same left hand side but different premises.</p>
</section><div><a class="slider-prev" href="#evaluation-relations"></a><a class="slider-next" href="#statement-evaluation"></a></div>
<section id="statement-evaluation" class="slide level1">
<h1>Statement evaluation</h1>
<h2 id="how-can-we-represent-the-evaluation-of-sequence-of-imperative-language-statements-in-pure-functional-programming-language">How can we represent the evaluation of sequence of imperative language statements in pure functional programming language?</h2>
</section><div><a class="slider-prev" href="#expression-evaluation-and-static-semantics"></a><a class="slider-next" href="#continuations"></a></div>
<section id="continuations" class="slide level1">
<h1>Continuations</h1>
<p>Continuation is a representation of execution state of a program (for example, the call stack) at a certain point of time. Continuation may be understood as dynamic <code>goto</code> instruction. By using continuations we may jump between different places of a program preserving the context of each.</p>
</section><div><a class="slider-prev" href="#statement-evaluation"></a><a class="slider-next" href="#continuations-in-practice"></a></div>
<section id="continuations-in-practice" class="slide level1">
<h1>Continuations in practice</h1>
C# <code>async</code>/<code>await</code> asynchronous execution keywords. <img data-src="images/IC612215.png" src="images/IC612215.png">
<div class="small">
Image source: <a href="https://msdn.microsoft.com/en-us/library/hh191443.aspx" class="uri">https://msdn.microsoft.com/en-us/library/hh191443.aspx</a>
</div>
</section><div><a class="slider-prev" href="#continuations"></a><a class="slider-next" href="#callback-hell"></a></div>
<section id="callback-hell" class="slide level1">
<h1>Callback hell</h1>
<p>Missing counter-example of asynchronous computations in language without continuations</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">copyFile</span>(onSuccess<span class="op">,</span> onFailure) {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> fs <span class="op">=</span> <span class="pp">require</span>(<span class="st">'fs'</span>)<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  fs<span class="op">.</span><span class="fu">readFile</span>(<span class="st">'file1.txt'</span><span class="op">,</span> { <span class="dt">encoding</span><span class="op">:</span> <span class="st">'utf-8'</span> }<span class="op">,</span> <span class="kw">function</span> (error<span class="op">,</span> data1) {</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (error) {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">onFailure</span>(error<span class="op">.</span><span class="at">code</span>)<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>      fs<span class="op">.</span><span class="fu">writeFile</span>(<span class="st">'file2.txt'</span><span class="op">,</span> data<span class="op">,</span> { <span class="dt">encoding</span><span class="op">:</span> <span class="st">'utf-8'</span> }<span class="op">,</span> <span class="kw">function</span> (error) {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (error) {</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>          <span class="fu">onFailure</span>(error<span class="op">.</span><span class="at">code</span>)<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>          <span class="fu">onSuccess</span>()<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>      })<span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    }   </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>} </span></code></pre></div>
</section><div><a class="slider-prev" href="#continuations-in-practice"></a><a class="slider-next" href="#continuations-in-clight-semantics"></a></div>
<section id="continuations-in-clight-semantics" class="slide level1">
<h1>Continuations in Clight semantics</h1>
<pre><code>Inductive cont: Type :=
  | Kstop: cont
  (* Kseq s2 k = after s1 in s1;s2 *)
  | Kseq: statement -&gt; cont -&gt; cont
  (* Kloop1 s1 s2 k = after s1 in Sloop s1 s2 *)
  | Kloop1: statement -&gt; statement -&gt; cont -&gt; cont
  (* Kloop2 s1 s2 k = after s2 in Sloop s1 s2 *)
  | Kloop2: statement -&gt; statement -&gt; cont -&gt; cont
  (* catches break statements arising out of switch *)
  | Kswitch: cont -&gt; cont
  | Kcall: option ident -&gt; (* where to store result *)
           function -&gt; (* calling function *)
           env -&gt; (* local env of calling function *)
           temp_env -&gt; (* temporary env of calling function *)
           cont -&gt; cont.</code></pre>
<p>Note that <code>Kcall</code> continuation constructor contains the definition and environments of calling function to be restored.</p>
</section><div><a class="slider-prev" href="#callback-hell"></a><a class="slider-next" href="#state"></a></div>
<section id="state" class="slide level1">
<h1>State</h1>
<p>Statements may modify memory state</p>
<pre><code>Inductive state: Type :=
  | State
      (f: function)
      (s: statement)
      (k: cont)
      (e: env)
      (le: temp_env)
      (m: mem) : state
  | Callstate
      (fd: fundef)
      (args: list val)
      (k: cont)
      (m: mem) : state
  | Returnstate
      (res: val)
      (k: cont)
      (m: mem) : state.</code></pre>
</section><div><a class="slider-prev" href="#continuations-in-clight-semantics"></a><a class="slider-next" href="#sequence-statement-evaluation-judgement"></a></div>
<section id="sequence-statement-evaluation-judgement" class="slide level1">
<h1>Sequence statement evaluation judgement</h1>
<pre><code>Inductive step: state -&gt; trace -&gt; state -&gt; Prop :=

  | step_assign: forall f a1 a2 k e le m loc ofs v2 v m',
      eval_lvalue e le m a1 loc ofs -&gt;
      eval_expr e le m a2 v2 -&gt;
      sem_cast v2 (typeof a2) (typeof a1) = Some v -&gt;
      assign_loc ge (typeof a1) m loc ofs v m' -&gt;
      step (State f (Sassign a1 a2) k e le m)
        E0 (State f Sskip k e le m')</code></pre>
</section><div><a class="slider-prev" href="#state"></a><a class="slider-next" href="#loop-statement-evaluation-judgements"></a></div>
<section id="loop-statement-evaluation-judgements" class="slide level1">
<h1>Loop statement evaluation judgements</h1>
<pre><code>| step_loop: forall f s1 s2 k e le m,
    step (State f (Sloop s1 s2) k e le m)
      E0 (State f s1 (Kloop1 s1 s2 k) e le m)
| step_skip_or_continue_loop1: forall f s1 s2 k e le m x,
    x = Sskip \/ x = Scontinue -&gt;
    step (State f x (Kloop1 s1 s2 k) e le m)
      E0 (State f s2 (Kloop2 s1 s2 k) e le m)
| step_break_loop1: forall f s1 s2 k e le m,
    step (State f Sbreak (Kloop1 s1 s2 k) e le m)
      E0 (State f Sskip k e le m)
| step_skip_loop2: forall f s1 s2 k e le m,
    step (State f Sskip (Kloop2 s1 s2 k) e le m)
      E0 (State f (Sloop s1 s2) k e le m)
| step_break_loop2: forall f s1 s2 k e le m,
    step (State f Sbreak (Kloop2 s1 s2 k) e le m)
      E0 (State f Sskip k e le m)</code></pre>
</section><div><a class="slider-prev" href="#sequence-statement-evaluation-judgement"></a><a class="slider-next" href="#homework-assignments"></a></div>
<section id="homework-assignments" class="slide level1">
<h1>Homework Assignments</h1>
<p><strong>Task 10.1.</strong> ** Manually translate non-trivial function body (10-20 lines of code) to Clight statement.</p>
<p>You can check syntax of your definition in Coq:</p>
<ol type="1">
<li class="fragment">Clone CompCert repository: <a href="https://github.com/AbsInt/CompCert" class="uri">https://github.com/AbsInt/CompCert</a></li>
<li class="fragment">Install CompCert prerequisites (Coq 8.8+, OCaml 4.05+, Menhir 20190626)</li>
<li class="fragment"><a href="https://compcert.org/man/manual002.html#install">Configure and compile CompCert</a>: <code>./configure x86_64-linux &amp;&amp; make</code></li>
<li class="fragment">Open CoqIDE with Clight module: <code>./coq cfrontend/Clight.v</code></li>
<li class="fragment">Append your code to the end of the file in separate definition:</li>
</ol>
<pre class="coq"><code>Definition endless_loop : statement :=
  Sloop Sskip Sskip.</code></pre>
<ol start="6" type="1">
<li class="fragment">Press Ctrl+End to check your code (or from menu: Navigation → End).</li>
</ol>
</section><div><a class="slider-prev" href="#loop-statement-evaluation-judgements"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  function handleKeydown(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 33: // Page Up
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 34: // Page Down
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  }
  document.addEventListener("keydown", handleKeydown);
  document.getElementById("flat-view").addEventListener("click", function(e) {
    document.getElementById("main").classList.toggle('slider');
    if (document.getElementById("main").classList.contains('slider')) {
      document.getElementById("container").style="width: 640px;height: 400px;";
      document.addEventListener("keydown", handleKeydown);
    } else {
      document.getElementById("container").style="";
      document.removeEventListener("keydown", handleKeydown);
    }
  })
  </script>
  

</body></html>
