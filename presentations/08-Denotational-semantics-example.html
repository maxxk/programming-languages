<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="denotational-semantics">Denotational semantics</h2>
<h3 id="domain-theory">Domain theory</h3>
<!--## Implementation of denotational semantics
### Monads and monad transformers-->
<h3 id="resumptions">Resumptions</h3>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: small !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
.reveal section {
  text-align: left;
}

.xits {
  font-family: "XITS Math", "XITS", "STIX", "PT Serif Caption", sans-serif !important;
}
</style>
<p>Course page: <a href="https://maxxk.github.io/programming-languages/" class="uri">https://maxxk.github.io/programming-languages/</a><br>
Contact author: <a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#some-non-trivial-parts-of-programming-language-semantics"></a></div>
<section id="some-non-trivial-parts-of-programming-language-semantics" class="slide level1">
<h1>Some non-trivial parts of programming language semantics</h1>
<ol type="1">
<li class="fragment"><p>Possible non-termination. Some languages allow possibly-infinite loops. Languages without non-termination have rather simple semantics.<br>
<strong>Operational semantics:</strong> sequence of steps form the directed graph (execution trace), non-termination is represented as a loop in graph.</p></li>
<li class="fragment"><p>Non-determinism. In some languages (for example, C) the order of execution of some expressions (e.g. the evaluation order of arguments) is unspecified. Furthermore, threads parallel programming model is essentially non-deterministic.<br>
<strong>Operational semantics:</strong> evaluation relations are many-valued.</p></li>
</ol>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#denotational-semantics-literature"></a></div>
<section id="denotational-semantics-literature" class="slide level1">
<h1>Denotational semantics: Literature</h1>
<div class="smaller">
<ol type="1">
<li class="fragment"><p>R.W. Sebesta. Concepts of Programming Languages, 2012.<br>
Section 3.5.2. Denotational semantics (pp. 142–147)<br>
— concise practical introduction, good for getting first impression.</p></li>
<li class="fragment"><p><strong>F.A. Turbak, D.K. Gifford. Desing Concepts in Programming Languages, 2008.<br>
Section 4. Denotational semantics, Section 5. Fixed Points. (pp. 113–204)</strong></p></li>
<li class="fragment"><p>D.A. Schmidt. Denotational Semantics: A Methodology for Language Development. 1997.<br>
A monograph on denotational semantics.</p></li>
<li class="fragment"><p>N.S. Papaspyrou. A Formal Semantics for the C Programming Language. 1998.<br>
PhD thesis.</p></li>
<li class="fragment"><p><strong>D.S. Scott. Logics and programming languages. 1977 <a href="http://dx.doi.org/10.1145/359810.359826">doi:10.1145/359810.359826</a><br>
1976 ACM Turing Award Lecture. The creator of domain theory and denotational semantics describes the history and the essence of the theory to wide audience.</strong></p></li>
<li class="fragment">Ю.Л. Ершов.</li>
</ol>
<ul>
<li class="fragment">Непрерывные решетки и A-пространства // Докл. АН СССР. — 1972. — Т. 207, No 3. — C. 523–526.</li>
<li class="fragment">Теория A-пространств // Алгебра и логика. — 1973. — T. 12, No 4. — C. 369–416.</li>
</ul>
</div>
</section><div><a class="slider-prev" href="#some-non-trivial-parts-of-programming-language-semantics"></a><a class="slider-next" href="#denotational-semantics-1"></a></div>
<section id="denotational-semantics-1" class="slide level1">
<h1>Denotational semantics</h1>
<p>The core idea of denotational semantics is compositionality. «The meaning of the whole is composed out of the meaning of the parts».<br>
Main parts:</p>
<ol type="1">
<li class="fragment"><p><strong>Syntactic algebra</strong> — abstract syntax representation, AST in our notation. Describes the syntax of the program.</p></li>
<li class="fragment"><p><strong>Semantic algebra</strong> — a collection of <strong>semantic domains</strong> along with functions that manipulate these domains. Models the meaning of program phrases.<br>
Usually the meaning of a program is an element of a function domain that maps <strong>context domains</strong> (analogue of configuration space in operational semantics) to an <strong>answer domain</strong> (e.g. <em>Int</em> domain for programs which compute some integer value).</p></li>
<li class="fragment"><p><strong>Meaning function</strong> maps the elements of the syntactic algebra to their meanings in the semantic algebra.</p></li>
</ol>
</section><div><a class="slider-prev" href="#denotational-semantics-literature"></a><a class="slider-next" href="#meaning-function"></a></div>
<section id="meaning-function" class="slide level1">
<h1>Meaning function</h1>
<p>Meaning function must be homomorphic under the AST composition.<br>
E.g. if we have some AST node <span class="math inline"><em>t</em></span> = <span class="math inline"><em>t</em>(<em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>, …, <em>t</em><sub><em>k</em></sub>)</span> and globally defined meaning function <span class="math inline"><em>M</em></span> then:<br>
<br><span class="math display"><em>M</em>(<em>t</em>)=<em>f</em><sub><em>t</em></sub>(<em>M</em>(<em>t</em><sub>1</sub>),<em>M</em>(<em>t</em><sub>2</sub>),…,<em>M</em>(<em>t</em><sub><em>k</em></sub>)), </span><br><br>
where <span class="math inline"><em>f</em><sub><em>t</em></sub></span> is a function over the semantic domain determined by the syntactic class of <span class="math inline"><em>t</em></span>.<br>
<img src="images/meaning-function.png"></p>
</section><div><a class="slider-prev" href="#denotational-semantics-1"></a><a class="slider-next" href="#meaning-function-definition"></a></div>
<section id="meaning-function-definition" class="slide level1">
<h1>Meaning function definition</h1>
<p>The usual notation for meaning function is <span class="math inline">⟦ · ⟧<sub>syntax-domain</sub></span>.<br>
The body of the meaning function is usually defined in terms of untyped lambda-calculus with some syntactic sugar:</p>
<ul>
<li class="fragment">conditional operator <strong>if</strong> … <strong>then</strong> … <strong>else</strong> with condition as a (decidable) predicate over the semantic domain</li>
<li class="fragment">pattern matching operator <strong>match</strong> ▷ pattern1 ↦ result1 … <strong>end</strong></li>
<li class="fragment">structural recursion: function can recursively call itself with arguments which are the structural parts of the original arguments</li>
</ul>
</section><div><a class="slider-prev" href="#meaning-function"></a><a class="slider-next" href="#example-imp"></a></div>
<section id="example-imp" class="slide level1">
<h1>Example: Imp'</h1>
<p>Simple imperative language with arithmetical and boolean expressions, assignment, conditional operator and loop.</p>
<p>Abstract syntax (omitting the operator precedence and lexical structure):</p>
<pre><code>Program = Statement "return" VariableName

Statement = VariableName "=" ArithmeticalExpression
| "skip"
| Statement (";" | "\n") Statement
| "if" "(" BooleanExpression ")" "{ " Statement " } else { " Statement " }"
| "while "(" BooleanExpression ")" "{ " Statement  "}"

ArithmeticalExpression = VariableName
| IntegerNumber
| "sqrt" ArithmeticalExpression
| "-" ArithmeticalExpression
| ArithmeticalExpression ("+" | "-" | "*" | "/" | "%") ArithmeticalExpression

BooleanExpression = ArithmeticalExpression ("&lt;" | "&gt;" | "==") ArithmeticalExpression
| "!" BooleanExpression
| BooleanExpression ("&amp;&amp;" | "||" | "^^")</code></pre>
</section><div><a class="slider-prev" href="#meaning-function-definition"></a><a class="slider-next" href="#imp-programs"></a></div>
<section id="imp-programs" class="slide level1">
<h1>Imp' programs</h1>
<ol type="1">
<li class="fragment"><p><code>a</code>, <code>b</code>, <code>c</code> are the quadratic equation coefficients.</p>
<pre><code>d = sqrt(b*b - 4*a*c)
x1 = (-b + d) / 2*a
x2 = (-b - d) / 2*a
if (x1 &gt; x2) {
  res = x1
} else {
  res = x2
}
return res</code></pre></li>
<li class="fragment"><p>Primality test for <code>n</code>. Returns <code>0</code> if <code>n</code> is prime, otherwise returns minimal <code>n</code> divisor.</p>
<pre><code>bound = sqrt(n)
i = 2
divisor=0
while (i &lt; bound &amp;&amp; divisor == 0) {
  if (n % i == 0) { divisor = n } else { skip };
}
return divisor</code></pre></li>
</ol>
</section><div><a class="slider-prev" href="#example-imp"></a><a class="slider-next" href="#naive-denotational-semantics"></a></div>
<section id="naive-denotational-semantics" class="slide level1">
<h1>Naive denotational semantics</h1>
<div class="smaller">
<h2 id="semantic-domains">Semantic domains</h2>
<p><em>Int</em> — integer numbers with addition, subtraction, division, modulus and integral approximation to square root and boolean-valued comparison operators (usually you want integer numbers mod <span class="math inline">2<sup>32</sup></span> or <span class="math inline">2<sup>64</sup></span>, but our language supports big integers).<br>
<em>Bool</em> — boolean values (<em>true</em>, <em>false</em>) with logical operations.</p>
<h2 id="expression-semantics-without-variables">Expression semantics (without variables)</h2>
<p><span class="math inline">⟦ · ⟧<sub>AE</sub> : ArithmeticalExpression → Int</span><br>
<span class="math inline">⟦IntegerNumber(<em>i</em>)⟧<sub>AE</sub> = ⟦<em>i</em>⟧<sub>IntegerNumber</sub></span><br>
$⟦ \text{sqrt}(e) ⟧_{\text{AE}} = \left[ \sqrt{⟦e⟧_{\text{AE}}} \right] $<br>
<span class="math inline">⟦ − <em>e</em>⟧<sub>AE</sub> = −⟦<em>e</em>⟧<sub>AE</sub></span><br>
<span class="math inline">⟦<em>e</em><sub>1</sub> <em>a</em><em>o</em><em>p</em> <em>e</em><sub>2</sub>⟧<sub>AE</sub> = ⟦<em>o</em><em>p</em>⟧<sub>AE-aop</sub>(⟦<em>e</em><sub>1</sub>⟧<sub>AE</sub>, ⟦<em>e</em><sub>2</sub>⟧<sub>AE</sub>)</span> [e.g. <span class="math inline">⟦<code></code>⟧<sub>AE-aop</sub> = mod</span>]</p>
<h2 id="boolean-expression-semantics">Boolean expression semantics</h2>
abop — arithmetical-boolean operator, bbop — boolean-boolean operator.<br>
<span class="math inline">⟦ · ⟧<sub>BE</sub> : BooleanExpression → Bool</span><br>
<span class="math inline">⟦<em>e</em><sub>1</sub> <em>a</em><em>b</em><em>o</em><em>p</em> <em>e</em><sub>2</sub>⟧<sub>BE</sub> = ⟦<em>a</em><em>b</em><em>o</em><em>p</em>⟧(⟦<em>e</em><sub>1</sub>⟧<sub>AE</sub>, ⟦<em>e</em><sub>2</sub>⟧<sub>AE</sub>)</span><br>
<span class="math inline">⟦<code>!</code><em>b</em>⟧<sub>BE</sub> = ¬⟦<em>b</em>⟧</span><br>
<span class="math inline">⟦<em>b</em><sub>1</sub> <em>b</em><em>b</em><em>o</em><em>p</em> <em>b</em><sub>2</sub>⟧<sub>BE</sub> = ⟦<em>b</em><em>b</em><em>o</em><em>p</em>⟧(⟦<em>b</em><sub>1</sub>⟧<sub>BE</sub>, ⟦<em>b</em><sub>2</sub>⟧<sub>BE</sub>)</span>
</div>
</section><div><a class="slider-prev" href="#imp-programs"></a><a class="slider-next" href="#environments"></a></div>
<section id="environments" class="slide level1">
<h1>Environments</h1>
<p>Expressions have read-only access to variables. It is represented in terms of environment (additional argument to the meaning function).<br>
<strong>Semantic domain:</strong> <em>VariableState ≡ Identifier → Int<span class="math inline"><sub>⟂</sub></span>,</em> <em>Int<span class="math inline"><sub>⟂</sub></span> = Int ∪ { ⟂ }</em> with bottom (⟂) value representing undefined variable state. We will discuss this construction later, for now let us just state that <span class="math inline"><em>f</em>(<em>x</em>, ⊥)=<em>f</em>(⟂, <em>x</em>)=⟂</span> for all defined functions.</p>
<p>Update meaning functions:<br>
<span class="math inline">$⟦ · ⟧_{\text{AE}} : \color{red}{\text{VariableState} →} \text{ArithmeticalExpression} → \text{Int}\color{red}{ {}_⟂}$</span><br>
All previously defined cases are updated to pass an environment to nested functions, for example:<br>
<span class="math inline">⟦ − <em>e</em>⟧=<em>λ</em><em>e</em><em>n</em><em>v</em>.−⟦<em>e</em>⟧(<em>e</em><em>n</em><em>v</em>)</span><br>
Now we can define the variable getter expression:<br>
<span class="math inline">⟦Identifier(<em>I</em>)⟧ = <em>λ</em><em>e</em><em>n</em><em>v</em>.<em>e</em><em>n</em><em>v</em>(<em>I</em>)</span></p>
<p>Boolean expressions also depend on variable values. Previously defined cases must me updated.<br>
<span class="math inline">$⟦ · ⟧_{\text{BE}} : \color{red}{\text{VariableState} →} \text{BooleanExpression} → \text{Bool}\color{red}{{}_⟂}$</span></p>
</section><div><a class="slider-prev" href="#naive-denotational-semantics"></a><a class="slider-next" href="#exceptions"></a></div>
<section id="exceptions" class="slide level1">
<h1>Exceptions</h1>
<div class="smaller">
<p>Now let us remember that we have three operators (<code>/, %, sqrt</code>) which are not universally defined over the integer numbers.<br>
<strong>Semantic domains:</strong></p>
<ul>
<li class="fragment">errors: <em>Error = { div-by-zero, sqrt-from-negative }</em></li>
<li class="fragment">domain sum constructor: <em>X + Error</em> are the values of either <em>X</em> or <em>Error</em>, with constructor <em>inl</em> converting <em>X</em> values to sum, constructor <em>inr</em> converting <em>Error</em> values to the sum.</li>
</ul>
<p><strong>Convenience function:</strong><br>
withLeft : (f : X → Y) → X + Error → Y + Error<br>
withLeft(f, x) = <strong>match</strong>(x)<br>
▷ <em>inl</em> a ↦ f(a)<br>
▷ <em>inr</em> e ↦ e<br>
<strong>end</strong></p>
<p><strong>Meaning functions:</strong><br>
<span class="math inline">⟦ · ⟧<sub>AE</sub> : VariableState → ArithmeticalExpression → Int<sub>⟂</sub> + Error</span><br>
<span class="math inline">⟦ · ⟧<sub>BE</sub> : VariableState → BooleanExpression → Bool<sub>⟂</sub> + Error</span></p>
<p><strong>Example meaning function update:</strong><br>
<span class="math inline">⟦ − <em>e</em>⟧=<em>λ</em><em>e</em><em>n</em><em>v</em>.withLeft(<em>λ</em><em>x</em>.−<em>x</em>, ⟦<em>e</em>⟧(<em>e</em><em>n</em><em>v</em>))</span></p>
</div>
</section><div><a class="slider-prev" href="#environments"></a><a class="slider-next" href="#statement-and-program-semantics"></a></div>
<section id="statement-and-program-semantics" class="slide level1">
<h1>Statement and program semantics</h1>
<h2 id="program">Program</h2>
<p>— receive the arguments and run statements. If statements completed without an error, get the return value.<br>
<span class="math inline">⟦ · ⟧<sub>P</sub> : VariableState → Int<sub>⊥</sub> + Error</span><br>
<span class="math inline">⟦<em>s</em><sub>1</sub>;  <code>return</code> <em>I</em>⟧=<em>λ</em><em>a</em><em>r</em><em>g</em><em>s</em>.withLeft(<em>λ</em><em>e</em><em>n</em><em>v</em>.<em>e</em><em>n</em><em>v</em>(<em>I</em>),⟦<em>s</em><sub>1</sub>⟧(<em>a</em><em>r</em><em>g</em><em>s</em>))</span></p>
<h2 id="statement">Statement</h2>
<p>Statements manipulate the variable environment not as a read-only environment, but as a read-write state.<br>
<span class="math inline">⟦ · ⟧<sub>S</sub> : VariableState → VariableState + Error</span><br>
<span class="math inline">⟦<code>skip</code>⟧=<em>λ</em><em>e</em><em>n</em><em>v</em>.inl(<em>e</em><em>n</em><em>v</em>)</span><br>
<span class="math inline">⟦<em>s</em><sub>1</sub> <code>;</code> <em>s</em><sub>2</sub>⟧=<em>λ</em><em>e</em><em>n</em><em>v</em>.withLeft(⟦<em>s</em><sub>2</sub>⟧,⟦<em>s</em><sub>1</sub>⟧(<em>e</em><em>n</em><em>v</em>))</span><br>
<span class="math inline">⟦<em>I</em> <code>=</code> <em>e</em>⟧=<em>λ</em><em>e</em><em>n</em><em>v</em>.withLeft(<em>λ</em><em>i</em>.(<em>λ</em><em>J</em>.if J=I return i else return env(J)),⟦<em>e</em>⟧(<em>e</em><em>n</em><em>v</em>))</span></p>
</section><div><a class="slider-prev" href="#exceptions"></a><a class="slider-next" href="#statements-2"></a></div>
<section id="statements-2" class="slide level1">
<h1>Statements (2)</h1>
<p>Let us adopt two shorthand notations for withLeft:</p>
<ul>
<li class="fragment">left composition: x &gt;&gt;= y ≡ withLeft(y, x)</li>
<li class="fragment">left variable binding: a ← b; S ≡ withLeft(λa. S, b)</li>
</ul>
<p><span class="math inline">⟦<code>if</code> <em>b</em><sub>1</sub> <em>s</em><sub><em>t</em></sub> <em>s</em><sub><em>f</em></sub>⟧=<em>λ</em><em>e</em><em>n</em><em>v</em>.<em>b</em>′←⟦<em>b</em><sub>1</sub>⟧(<em>e</em><em>n</em><em>v</em>);</span><br>
<span class="math inline">  </span> <strong>if</strong> <span class="math inline">(<em>b</em>′=<sub>Bool</sub>true)</span> <span class="math inline">⟦<em>s</em><sub><em>t</em></sub>⟧(<em>e</em><em>n</em><em>v</em>)</span><br>
<span class="math inline">  </span> <strong>else</strong> <span class="math inline">⟦<em>s</em><sub><em>f</em></sub>⟧(<em>e</em><em>n</em><em>v</em>)</span></p>
</section><div><a class="slider-prev" href="#statement-and-program-semantics"></a><a class="slider-next" href="#independent-execution-branches-in-legacy-code-with-automated-static-analysis-tools"></a></div>
<section id="independent-execution-branches-in-legacy-code-with-automated-static-analysis-tools" class="slide level1">
<h1>Independent execution branches in legacy code with automated static analysis tools</h1>
<h2 id="example-application-of-denotational-semantics">Example application of denotational semantics</h2>
</section><div><a class="slider-prev" href="#statements-2"></a><a class="slider-next" href="#task"></a></div>
<section id="task" class="slide level1">
<h1>Task</h1>
<p>Transform the existing legacy single-dimensional thermal-hydraulics code. Code is<br>
written in Fortran, memory is statically distributed.</p>
<p>Prove the correctness of the parallel execution.</p>
</section><div><a class="slider-prev" href="#independent-execution-branches-in-legacy-code-with-automated-static-analysis-tools"></a><a class="slider-next" href="#scheme-of-the-solution"></a></div>
<section id="scheme-of-the-solution" class="slide level1">
<h1>Scheme of the solution</h1>
<ol type="1">
<li class="fragment">Describe the formal semantics of the code.</li>
<li class="fragment">Expand the non-trivial syntactic constructions (partial evaluation).</li>
<li class="fragment">Transform the code to the static single assignment form (SSA).</li>
<li class="fragment">Define the dynamic semantics of code (in terms of substitution).</li>
<li class="fragment">Transform code to the model of dynamical concurrent exection.</li>
<li class="fragment">Show the correctness of the transformation (abstract interpretation).</li>
<li class="fragment">Schedule tasks statically.</li>
</ol>
</section><div><a class="slider-prev" href="#task"></a><a class="slider-next" href="#code-structure"></a></div>
<section id="code-structure" class="slide level1">
<h1>Code structure</h1>
<p>Thermal-hydraulics system model is a graph with differently-typed nodes (pipes, pumps, etc.).<br>
Objects have different properties (pressure, temperature).<br>
All properties of the same type are stored in separate array.<br>
Arrays are mapped to common blocks to synchronize with external modules of the whole system.</p>
<p>Code is generated automatically based on thermal-hydraulical system model. Main function consists of the sequence of stages, each stage is repeated for each of 7 stages which compute the updated values for some related parameter groups, in separate lines of code for each object.</p>
<p>Mapping of variables to common blocks is specified in header files.</p>
<p>In total for a real model (about 2000 objects) there are 424 000 lines of code in subset of Fortran.</p>
</section><div><a class="slider-prev" href="#scheme-of-the-solution"></a><a class="slider-next" href="#previous-work"></a></div>
<section id="previous-work" class="slide level1">
<h1>Previous work</h1>
<ul>
<li class="fragment">we tried running computations for each subsystem in separate process</li>
<li class="fragment">for each stage and for each subsystem we select memory blocks which are read and written at that stage</li>
<li class="fragment">before each stage processes synchronize required block values</li>
</ul>
<p>Result: stages+subsystems are coarsely grained, almost no improvement in parallel distributed execution mode.</p>
</section><div><a class="slider-prev" href="#code-structure"></a><a class="slider-next" href="#fortran-subset-syntax"></a></div>
<section id="fortran-subset-syntax" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="header-files">Header files</h2>
<div class="sourceCode"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span class="dt">CHARACTER*1</span> G03th_z1
<span class="kw">COMMON/</span>global03th_z1<span class="kw">/</span>G03th_z1(<span class="dv">0</span>:<span class="dv">819199</span>)
<span class="dt">CHARACTER*1</span> G14
<span class="kw">COMMON/</span>global14<span class="kw">/</span>G14(<span class="dv">0</span>:<span class="dv">3276799</span>)
<span class="dt">CHARACTER*1</span> G04th_z1
<span class="kw">COMMON/</span>global04th_z1<span class="kw">/</span>G04th_z1(<span class="dv">0</span>:<span class="dv">819199</span>)
<span class="dt">CHARACTER*1</span> G15_z1
<span class="kw">COMMON/</span>global15_z1<span class="kw">/</span>G15_z1(<span class="dv">0</span>:<span class="dv">1638399</span>)
<span class="dt">REAL*8</span>    chkfim
<span class="kw">EQUIVALENCE</span> (chkfim,G14(<span class="dv">46632</span>))
<span class="dt">LOGICAL</span><span class="kw">*</span><span class="dv">1</span> th_pumpcav_<span class="dv">1</span>(<span class="dv">4</span>) 
<span class="kw">EQUIVALENCE</span> (th_pumpcav_<span class="dv">1</span>,G03th_z1(<span class="dv">78992</span>))
<span class="dt">REAL*8</span>    thdfpp1_<span class="dv">1</span>(<span class="dv">563</span>,<span class="dv">2</span>) 
<span class="kw">EQUIVALENCE</span> (thdfpp1_<span class="dv">1</span>,G15_z1(<span class="dv">686920</span>))</code></pre></div>
</section><div><a class="slider-prev" href="#previous-work"></a><a class="slider-next" href="#fortran-subset-syntax-1"></a></div>
<section id="fortran-subset-syntax-1" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="header-files-1">Header files</h2>
<pre><code>&lt;head&gt; ::= (&lt;head_decl&gt; | &lt;head_comm&gt; | &lt;head_equiv&gt;)+ ;

// Variable declaration:
&lt;head_decl&gt; ::= &lt;type&gt; &lt;identifier&gt; &lt;length&gt;?;

// Common block declaration:
&lt;head_comm&gt; ::= "COMMON/" &lt;identifier&gt; ("/" &lt;identifier&gt;)* 
    "(" &lt;positiveLiteral&gt; ":" &lt;positiveLiteral&gt; ")";

// Variable mapping
&lt;head_equiv&gt; ::= "EQUIVALENCE" "(" &lt;identifier&gt; "," &lt;identifier&gt;" "(" &lt;positiveLiteral&gt; ")" ")"

&lt;type&gt; ::= 
    "CHARACTER" "*" &lt;positiveLiteral&gt; 
    | "REAL" "*" &lt;positiveLiteral&gt;
    | "INTEGER" "*" &lt;positiveLiteral&gt;
    | "LOGICAL" "*" &lt;positiveLiteral&gt;</code></pre>
</section><div><a class="slider-prev" href="#fortran-subset-syntax"></a><a class="slider-next" href="#fortran-subset-syntax-2"></a></div>
<section id="fortran-subset-syntax-2" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="source-code-files">Source code files</h2>
<div class="sourceCode"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">1</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">862</span> ), y1mtmp( <span class="dv">863</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1054</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1055</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">13</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">14</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">13</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">14</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">1</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">1</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">1</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">1</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">1</span> ), fwdtt_<span class="dv">1</span>, kf0 )

<span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">2</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">863</span> ), y1mtmp( <span class="dv">864</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1055</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1056</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">14</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">15</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">14</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">15</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">2</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">2</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">2</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">2</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">2</span> ), fwdtt_<span class="dv">1</span>, kf0 )

<span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">3</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">850</span> ), y1mtmp( <span class="dv">851</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1042</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1043</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">1</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">2</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">1</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">2</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">3</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">3</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">3</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">3</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">3</span> ), fwdtt_<span class="dv">1</span>, kf0 )

<span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">4</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">852</span> ), y1mtmp( <span class="dv">853</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1044</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1045</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">3</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">4</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">3</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">4</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">4</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">4</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">4</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">4</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">4</span> ), fwdtt_<span class="dv">1</span>, kf0 )

<span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">5</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">851</span> ), y1mtmp( <span class="dv">854</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1043</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1046</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">2</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">5</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">2</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">5</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">5</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">5</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">5</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">5</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">5</span> ), fwdtt_<span class="dv">1</span>, kf0 )

<span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">6</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">853</span> ), y1mtmp( <span class="dv">854</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1045</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1046</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">4</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">5</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">4</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">5</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">6</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">6</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">6</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">6</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">6</span> ), fwdtt_<span class="dv">1</span>, kf0 )</code></pre></div>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-1"></a><a class="slider-next" href="#fortran-subset-syntax-3"></a></div>
<section id="fortran-subset-syntax-3" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="source-code">Source code</h2>
<pre><code>&lt;program&gt; ::= &lt;header&gt; &lt;include&gt; &lt;preliminary&gt;* &lt;statements&gt; "END"

&lt;header&gt; ::= ("SUBROUTINE" | "FUNCTION") identifier ("(" &lt;identifiers&gt; ")")?
&lt;include&gt; ::= "INCLUDE" "'" &lt;identifier&gt; ".h'"
&lt;preliminary&gt; ::= &lt;type&gt; &lt;declarators&gt; | "DATA" &lt;dataDeclarators&gt;

&lt;statements&gt; ::= &lt;statement&gt; &lt;statement&gt;*;
&lt;statement&gt; ::=
    &lt;lvalue&gt; "=" &lt;expression&gt; 
    | &lt;positiveLiteral&gt; "CONTINUE" 
    | "CALL" &lt;identifier&gt; "(" &lt;expressions&gt; ")"
    | "IF" "(" &lt;expression&gt; ")" "THEN"? &lt;statements&gt;
        ("ELSE" "IF" "(" &lt;expression&gt; ")" "THEN" &lt;statements&gt; )*
        ("ELSE" &lt;statements&gt;)?
        "END IF"
    | "DO" &lt;identifier&gt; = &lt;expression&gt; "," &lt;expression&gt; ("," &lt;integerLiteral&gt;)?
        &lt;statements&gt;
      "END DO"
    | "DO" "WHILE" "(" &lt;expression&gt; ")" &lt;statements&gt; "END" "DO"
    | "RETURN"
</code></pre>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-2"></a><a class="slider-next" href="#fortran-subset-syntax-4"></a></div>
<section id="fortran-subset-syntax-4" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="source-code-1">Source code</h2>
<p>Infix operators priority is irrelevant in our dynamical semantics models.</p>
<pre><code>&lt;lvalue&gt; ::= &lt;identifier&gt; ("(" &lt;expressions&gt; ")")?
&lt;expression&gt; ::= 
      &lt;simple_expression&gt; &lt;binop&gt; &lt;expression&gt; 
    | &lt;simple_expression&gt;

&lt;binop&gt; ::= ".EQ." | ".NE." | ".GE." | ".LE." | ".LT." | ".GT." | ".AND." | ".OR." 
    | "+" | "-" | "/" | "**" | "*"

&lt;unop&gt; ::= ".NOT." | "-"

&lt;simple_expression&gt; ::=
    "(" &lt;expression&gt; ")"
    | &lt;literal&gt;
    | &lt;identifier&gt;
    | &lt;identifier&gt; "(" &lt;expressions&gt; ")"
    | &lt;identifier&gt; "(" ")"
    | &lt;unop&gt; &lt;expression&gt;</code></pre>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-3"></a><a class="slider-next" href="#model-of-dynamical-concurrent-program-execution"></a></div>
<section id="model-of-dynamical-concurrent-program-execution" class="slide level1">
<h1>Model of dynamical concurrent program execution</h1>
<p>Modifier (extension) of static and dynamic denotational semantics for the existing<br>
programming languages.</p>
<p>Statements =</p>
<ul>
<li class="fragment">compute c</li>
<li class="fragment">s<span class="math inline"><sub>1</sub></span> ; s<span class="math inline"><sub>2</sub></span></li>
<li class="fragment">v = spawn t, c</li>
<li class="fragment">wait v, m</li>
</ul>
<p>Requirement: computations are purely functional (no global modifiable state)<br>
Property (theorem): correctness of the parallel execution.</p>
<p>Vasenin V. A., Krivchikov M. A. A model of dynamical concurrent program execution // Programming and Computer Software. — 2013. — Vol. 39, no. 1. — P. 1–9.</p>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-4"></a><a class="slider-next" href="#fortran-subset-static-formal-semantics"></a></div>
<section id="fortran-subset-static-formal-semantics" class="slide level1">
<h1>Fortran subset static formal semantics</h1>
<p>Identifiers are uniquely mapped to the block in which it is mapped.</p>
<p>Location : identifier → MemoryBlock × Offset × Size</p>
<p>Memory blocks are annotated with non-negative number (version). Version is increased at the time of the assignment.<br>
Classical intermediate representation: SSA (static single assignment form).<br>
SSA defines mutable variables as a sequence of immutable values.</p>
<p>Version : MemoryBlock × Offset × Size → N</p>
<p>Local variables may be represented in terms of the separate memory block.</p>
</section><div><a class="slider-prev" href="#model-of-dynamical-concurrent-program-execution"></a><a class="slider-next" href="#построение-статической-семантики"></a></div>
<section id="построение-статической-семантики" class="slide level1">
<h1>Построение статической семантики</h1>
<ol type="1">
<li class="fragment">Вызовы функций заменяются на код функции с подстановкой значений переменных и выделением новой памяти под локальные переменные, или заменяется операторами множественного присваивания со специальными функциональными символами.</li>
<li class="fragment">Циклы <code>DO</code> с постоянными границами раскрываются.</li>
<li class="fragment">Циклы <code>DO WHILE</code> и условные операторы <code>IF</code> на верхнем уровне заменяются операторами присваивания со специальными функциональными символами.</li>
<li class="fragment">Идентификаторы заменяются на тройки MemoryBlock × Offset × N<br>
I₁ = f(I₂, ..., Iₙ)</li>
</ol>
<p>(Location I₁, Version (Location I₁)+1) := f((Location I₂, Version(Location I₂)), ..., (Location Iₙ, Version(Location Iₙ)))</p>
<p>Version[Location I₁] ← Version[Location I₁] + 1</p>
</section><div><a class="slider-prev" href="#fortran-subset-static-formal-semantics"></a><a class="slider-next" href="#построение-статическодля-локальных-переменных-выделяется-специальный-блок-памяти.й-семантики"></a></div>
<section id="построение-статическодля-локальных-переменных-выделяется-специальный-блок-памяти.й-семантики" class="slide level1">
<h1>Построение статическоДля локальных переменных выделяется специальный блок памяти.й семантики</h1>
<h2 id="операторы-множественного-присваивания">Операторы множественного присваивания</h2>
<div class="sourceCode"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span class="kw">IF</span> ( f_temp1 <span class="op">.GT.</span> thhgconv ) <span class="kw">THEN</span>
    htcarg1 <span class="kw">=</span> f_temp1 <span class="kw">*</span> fipnt <span class="kw">+</span> thhgconv <span class="kw">*</span> ( kf1 <span class="kw">-</span> fipnt )
    mode <span class="kw">=</span> <span class="dv">6</span>
<span class="kw">ELSE</span>
    htcarg1 <span class="kw">=</span> thhgconv
    mode <span class="kw">=</span> <span class="dv">15</span>
<span class="kw">END IF</span></code></pre></div>
<p>(htcarg1, mode) = IF1234(f_temp1, thhgconv, fipnt, kf1)</p>
</section><div><a class="slider-prev" href="#построение-статической-семантики"></a><a class="slider-next" href="#динамическая-семантика"></a></div>
<section id="динамическая-семантика" class="slide level1">
<h1>Динамическая семантика</h1>
<p>описывается в терминах подстановок:</p>
<p>В результате построения статической семантики программа преобразуется в последовательность операторов множественного присваивания, в правой части которых находятся выражения или функциональные символы.</p>
<p>Окружение динамической семантики сохраняет представление статической семантики <em>выражений</em>:<br>
I₁ = (G₁, O₁, V₁) := f₁(...)<br>
...<br>
Iₙ = (Gₙ, Oₙ, Vₙ) := fₙ(...)</p>
<p>⟦J = (Gⱼ, Oⱼ, Vⱼ) := g(I₁, ..., Iₙ)⟧ = J = (Gⱼ, Oⱼ, Vⱼ) := g(f₁(...), ..., fₙ(...))</p>
</section><div><a class="slider-prev" href="#построение-статическодля-локальных-переменных-выделяется-специальный-блок-памяти.й-семантики"></a><a class="slider-next" href="#выделение-ветвей-вычислений"></a></div>
<section id="выделение-ветвей-вычислений" class="slide level1">
<h1>Выделение ветвей вычислений</h1>
<p>Выделение независимых ветвей вычислений выполняется путём выражения операторов присваивания и получения значения переменной в терминах модели динамического параллельного исполнения программ.</p>
<p>Каждый оператор присваивания выполняется в собственном потоке.</p>
<p>Окружение динамической семантики сохраняет для версии смещения в блоке памяти идентификатор потока и номер результата в множественном присваивании:<br>
I₁ = (G₁, O₁, V₁) := T₁, k₁<br>
...<br>
Iₙ = (Gₙ, Oₙ, Vₙ) := Tₙ, kₙ</p>
<p>⟦J = (Gⱼ, Oⱼ, Vⱼ) := g(I₁, ..., Iₙ)⟧ =<br>
J = (Gⱼ, Oⱼ, Vⱼ) := spawn g [ I₁ := wait T₁, k₁; ...; Iₙ := wait Tₙ, kₙ ]</p>
<p>Режим исполнения "по порядку" на динамической семантике в терминах подстановок должен порождать аналогичное исходной версии окружение динамической семантики (итоговые выражения получатся точно такими же).<br>
Это свойство проверяется в явном виде.</p>
</section><div><a class="slider-prev" href="#динамическая-семантика"></a><a class="slider-next" href="#статическое-планирование"></a></div>
<section id="статическое-планирование" class="slide level1">
<h1>Статическое планирование</h1>
<p>В отличие от ранних подходов, в данном случае размер гранулы получается слишком мелким. С учётом особенностей распространения продукта, в состав которого входит код (аппаратно-программный комплекс), предлагается использовать статическое планирование:</p>
<p>Модель динамического параллельного исполнения программ выполняется перед компиляцией, управляющее ядро предоставляет статический планировщик.</p>
<p>С точки зрения статической семантики — к каждому оператору присваивания приписывается номер процесса, в котором он выполняется.</p>
<p>В зависимости от используемого стандарта параллельных вычислений, команды spawn и wait раскрываются в последовательность функций одной из реализаций (аналогично пропрограммам В.А. Роганова).</p>
</section><div><a class="slider-prev" href="#выделение-ветвей-вычислений"></a><a class="slider-next" href="#модель-стоимости"></a></div>
<section id="модель-стоимости" class="slide level1">
<h1>Модель стоимости</h1>
<p>Для эффективного планирования потоков необходима дополнительная информация об ожидаемом времени вычисления того или иного выражения.</p>
<p>Параметры модели:</p>
<ol type="1">
<li class="fragment">Стоимость бинарных и унарных операций над числами.</li>
<li class="fragment">Стоимость функциональных символов — оценка максимальной сложности тела цикла (оператора IF).</li>
<li class="fragment">Стоимость пересылки (учитывается только при необходимости пересылки).</li>
</ol>
<p>В окружении планировщика сохраняется информация о номерах процессов, на которых выполняются потоки вычисления.</p>
<pre><code>ComputationCost : Computation → N
MessageCost : Schedule × TId × TId → N
Cost(S, J = (Gⱼ, Oⱼ, Vⱼ) := spawn g [ I₁ := wait T₁, k₁, ..., Iₙ := wait Tₙ, kₙ  ]) 
    = ComputationCost(g) 
    + Σᵢ MessageCost(g, Tᵢ)</code></pre>
<p>Задача оптимизации стоимости является NP-трудной, поэтому оптимальное решение найти на практике невозможно (но для практических задач хватит "достаточно быстрого" решения)</p>
</section><div><a class="slider-prev" href="#статическое-планирование"></a><a class="slider-next" href="#последовательное-выполнение-базовая-отметка"></a></div>
<section id="последовательное-выполнение-базовая-отметка" class="slide level1">
<h1>Последовательное выполнение (базовая отметка)</h1>
<ol type="1">
<li class="fragment">Стоимость бинарных и унарных операций над числами — 1.</li>
<li class="fragment">Стоимость функциональных символов — вычисляется на основе стоимости операций.</li>
<li class="fragment">Стоимость пересылки — 0.</li>
</ol>
<p>Количество процессов = 1</p>
</section><div><a class="slider-prev" href="#модель-стоимости"></a><a class="slider-next" href="#mpi"></a></div>
<section id="mpi" class="slide level1">
<h1>MPI</h1>
<ol type="1">
<li class="fragment">Стоимость бинарных и унарных операций над числами — 1.</li>
<li class="fragment">Стоимость функциональных символов — вычисляется на основе стоимости операций.</li>
<li class="fragment">Стоимость пересылки — 1000 (mpi_ping)</li>
</ol>
</section><div><a class="slider-prev" href="#последовательное-выполнение-базовая-отметка"></a><a class="slider-next" href="#threads"></a></div>
<section id="threads" class="slide level1">
<h1>Threads</h1>
<ol type="1">
<li class="fragment">Стоимость бинарных и унарных операций над числами — 1.</li>
<li class="fragment">Стоимость функциональных символов — вычисляется на основе стоимости операций.</li>
<li class="fragment">Стоимость пересылки — 1.</li>
</ol>
<p>Количество процессов = 2..60 (Xeon Phi)</p>
</section><div><a class="slider-prev" href="#mpi"></a><a class="slider-next" href="#malt"></a></div>
<section id="malt" class="slide level1">
<h1>MALT</h1>
<p>перспективная многоядерная архитектура процессоров, разрабатываемая на физическом факультете МГУ совместно с ФГУП НИИ Квант.</p>
<ul>
<li class="fragment">аппаратная поддержка лёгких потоков (F/E-биты)</li>
<li class="fragment">нет аппаратной поддержки вычислений с плавающей точкой</li>
<li class="fragment">стоимость операций — мои спекулятивные оценки</li>
</ul>
<ol type="1">
<li class="fragment">Стоимость бинарных и унарных операций над числами — 1..200 (SoftFloat).</li>
<li class="fragment">Стоимость функциональных символов — вычисляется на основе стоимости операций.</li>
<li class="fragment">Стоимость пересылки — 1.</li>
</ol>
<p>Количество процессов: ~100-1000.<br>
Гипотеза: высокая степень параллелизма и очень "дешёвые" пересылки могут перекрыть плохую производительность программной эмуляции вычислений с плавающей точкой.</p>
</section><div><a class="slider-prev" href="#threads"></a><a class="slider-next" href="#дальнейшая-работа"></a></div>
<section id="дальнейшая-работа" class="slide level1">
<h1>Дальнейшая работа</h1>
<ul>
<li class="fragment">программная реализация описанной модели</li>
<li class="fragment">испытания</li>
</ul>
<h2 id="перспективы">Перспективы</h2>
<ul>
<li class="fragment">вернуть в модель явное решение разреженной системы линейных уравнений методом LU-разложения</li>
<li class="fragment">пакетные пересылки MPI (MessageCost : Schedule × TId × TId × Size → N = C + k*Size)</li>
<li class="fragment">учёт SIMD-операций</li>
<li class="fragment">локальные микрооптимизации и постоптимизации кода</li>
<li class="fragment">подобрать метод аппроксимации решения задачи планирования</li>
</ul>
</section><div><a class="slider-prev" href="#malt"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>
