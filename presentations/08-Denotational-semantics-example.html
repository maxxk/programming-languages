<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>08-Denotational-semantics-example</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;" id="container">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator" id="main">
   <a id="slider-default"></a>
   <label title="Flat view" id="flat-view"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="denotational-semantics">Denotational semantics</h2>
<h3 id="domain-theory">Domain theory</h3>
<!--## Implementation of denotational semantics
### Monads and monad transformers-->
<h3 id="resumptions">Resumptions</h3>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: small !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
.reveal section {
  text-align: left;
}

.xits {
  font-family: "XITS Math", "XITS", "STIX", "PT Serif Caption", sans-serif !important;
}
</style>
<p><a href="https://maxxk.github.io/programming-languages/" class="uri">https://maxxk.github.io/programming-languages/</a></p>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#some-non-trivial-parts-of-programming-language-semantics"></a></div>
<section id="some-non-trivial-parts-of-programming-language-semantics" class="slide level1">
<h1>Some non-trivial parts of programming language semantics</h1>
<ol type="1">
<li class="fragment">Possible non-termination. Some languages allow possibly-infinite loops. Languages without non-termination have rather simple semantics.</li>
</ol>
<p><strong>Operational semantics:</strong> sequence of steps form the directed graph (execution trace), non-termination is represented as a loop in graph.</p>
<ol start="2" type="1">
<li class="fragment">Non-determinism. In some languages (for example, C) the order of execution of some expressions (e.g.&nbsp;the evaluation order of arguments) is unspecified. Furthermore, threads parallel programming model is essentially non-deterministic.</li>
</ol>
<p><strong>Operational semantics:</strong> evaluation relations are many-valued.</p>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#denotational-semantics-literature"></a></div>
<section id="denotational-semantics-literature" class="slide level1">
<h1>Denotational semantics: Literature</h1>
<div class="smaller">
<ol type="1">
<li class="fragment"><p>R.W. Sebesta. Concepts of Programming Languages, 2012. Section 3.5.2. Denotational semantics (pp.&nbsp;142–147) — concise practical introduction, good for getting first impression.</p></li>
<li class="fragment"><p><strong>F.A. Turbak, D.K. Gifford. Desing Concepts in Programming Languages, 2008. Section 4. Denotational semantics, Section 5. Fixed Points. (pp.&nbsp;113–204)</strong></p></li>
<li class="fragment"><p>D.A. Schmidt. Denotational Semantics: A Methodology for Language Development. 1997. A monograph on denotational semantics.</p></li>
<li class="fragment"><p>N.S. Papaspyrou. A Formal Semantics for the C Programming Language. 1998. PhD thesis.</p></li>
<li class="fragment"><p><strong>D.S. Scott. Logics and programming languages. 1977 <a href="http://dx.doi.org/10.1145/359810.359826">doi:10.1145/359810.359826</a></strong></p>
<p>1976 ACM Turing Award Lecture. The creator of domain theory and denotational semantics describes the history and the essence of the theory to wide audience.</p></li>
<li class="fragment"><p>Ю.Л. Ершов.</p></li>
</ol>
<ul>
<li class="fragment">Непрерывные решетки и A-пространства // Докл. АН СССР. — 1972. — Т. 207, No 3. — C. 523–526.</li>
<li class="fragment">Теория A-пространств // Алгебра и логика. — 1973. — T. 12, No 4. — C. 369–416.</li>
</ul>
</div>
</section><div><a class="slider-prev" href="#some-non-trivial-parts-of-programming-language-semantics"></a><a class="slider-next" href="#denotational-semantics-1"></a></div>
<section id="denotational-semantics-1" class="slide level1">
<h1>Denotational semantics</h1>
<p>The core idea of denotational semantics is compositionality. «The meaning of the whole is composed out of the meaning of the parts». Main parts:</p>
<ol type="1">
<li class="fragment"><p><strong>Syntactic algebra</strong> — abstract syntax representation, AST in our notation. Describes the syntax of the program.</p></li>
<li class="fragment"><p><strong>Semantic algebra</strong> — a collection of <strong>semantic domains</strong> along with functions that manipulate these domains. Models the meaning of program phrases. Usually the meaning of a program is an element of a function domain that maps <strong>context domains</strong> (analogue of configuration space in operational semantics) to an <strong>answer domain</strong> (e.g.&nbsp;<em>Int</em> domain for programs which compute some integer value).</p></li>
<li class="fragment"><p><strong>Meaning function</strong> maps the elements of the syntactic algebra to their meanings in the semantic algebra.</p></li>
</ol>
</section><div><a class="slider-prev" href="#denotational-semantics-literature"></a><a class="slider-next" href="#meaning-function"></a></div>
<section id="meaning-function" class="slide level1">
<h1>Meaning function</h1>
<p>Meaning function is desired to be homomorphic under the AST composition. E.g. if we have some AST node <span class="math inline"><em>t</em></span> = <span class="math inline"><em>t</em>(<em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>, …, <em>t</em><sub><em>k</em></sub>)</span> and globally defined meaning function <span class="math inline"><em>M</em></span> then: <br><span class="math display"><em>M</em>(<em>t</em>) = <em>f</em><sub><em>t</em></sub>(<em>M</em>(<em>t</em><sub>1</sub>), <em>M</em>(<em>t</em><sub>2</sub>), …, <em>M</em>(<em>t</em><sub><em>k</em></sub>)),</span><br> where <span class="math inline"><em>f</em><sub><em>t</em></sub></span> is a function over the semantic domain determined by the syntactic class of <span class="math inline"><em>t</em></span>. <img data-src="images/meaning-function.png" src="images/meaning-function.png"></p>
</section><div><a class="slider-prev" href="#denotational-semantics-1"></a><a class="slider-next" href="#meaning-function-definition"></a></div>
<section id="meaning-function-definition" class="slide level1">
<h1>Meaning function definition</h1>
<p>The usual notation for meaning function is <span class="math inline">⟦ · ⟧<sub>syntax-domain</sub></span>. The body of the meaning function is usually defined in terms of untyped lambda-calculus with some syntactic sugar:</p>
<ul>
<li class="fragment">conditional operator <strong>if</strong> … <strong>then</strong> … <strong>else</strong> with condition as a (decidable) predicate over the semantic domain</li>
<li class="fragment">pattern matching operator <strong>match</strong> ▷ pattern1 ↦ result1 … <strong>end</strong></li>
<li class="fragment">structural recursion: function can recursively call itself with arguments which are the structural parts of the original arguments</li>
</ul>
</section><div><a class="slider-prev" href="#meaning-function"></a><a class="slider-next" href="#example-imp"></a></div>
<section id="example-imp" class="slide level1">
<h1>Example: Imp’</h1>
<p>Simple imperative language with arithmetical and boolean expressions, assignment, conditional operator and loop.</p>
<p>Abstract syntax (omitting the operator precedence and lexical structure):</p>
<pre><code>Program = Statement "return" VariableName

Statement = VariableName "=" ArithmeticalExpression
| "skip"
| Statement (";" | "\n") Statement
| "if" "(" BooleanExpression ")" "{ " Statement " } else { " Statement " }"
| "while "(" BooleanExpression ")" "{ " Statement  "}"

ArithmeticalExpression = VariableName
| IntegerNumber
| "sqrt" ArithmeticalExpression
| "-" ArithmeticalExpression
| ArithmeticalExpression ("+" | "-" | "*" | "/" | "%") ArithmeticalExpression

BooleanExpression = ArithmeticalExpression ("&lt;" | "&gt;" | "==") ArithmeticalExpression
| "!" BooleanExpression
| BooleanExpression ("&amp;&amp;" | "||" | "^^")</code></pre>
</section><div><a class="slider-prev" href="#meaning-function-definition"></a><a class="slider-next" href="#imp-programs"></a></div>
<section id="imp-programs" class="slide level1">
<h1>Imp’ programs</h1>
<ol type="1">
<li class="fragment"><code>a</code>, <code>b</code>, <code>c</code> are the quadratic equation coefficients.</li>
</ol>
<pre><code>d = sqrt(b*b - 4*a*c)
x1 = (-b + d) / 2*a
x2 = (-b - d) / 2*a
if (x1 &gt; x2) {
  res = x1
} else {
  res = x2
}
return res</code></pre>
<ol start="2" type="1">
<li class="fragment">Primality test for <code>n</code>. Returns <code>0</code> if <code>n</code> is prime, otherwise returns minimal <code>n</code> divisor.</li>
</ol>
<pre><code>bound = sqrt(n)
i = 2
divisor=0
while (i &lt; bound &amp;&amp; divisor == 0) {
  if (n % i == 0) { divisor = n } else { skip };
}
return divisor</code></pre>
</section><div><a class="slider-prev" href="#example-imp"></a><a class="slider-next" href="#naive-denotational-semantics"></a></div>
<section id="naive-denotational-semantics" class="slide level1">
<h1>Naive denotational semantics</h1>
<div class="smaller">
<h2 id="semantic-domains">Semantic domains</h2>
<p><em>Int</em> — integer numbers with addition, subtraction, division, modulus and integral approximation to square root and boolean-valued comparison operators (usually you want integer numbers mod <span class="math inline">2<sup>32</sup></span> or <span class="math inline">2<sup>64</sup></span>, but our language supports big integers).</p>
<p><em>Bool</em> — boolean values (<em>true</em>, <em>false</em>) with logical operations.</p>
<h2 id="expression-semantics-without-variables">Expression semantics (without variables)</h2>
<p><span class="math inline">⟦ · ⟧<sub>AE</sub> : ArithmeticalExpression → Int</span></p>
<p><span class="math inline">⟦IntegerNumber(<em>i</em>)⟧<sub>AE</sub> = ⟦<em>i</em>⟧<sub>IntegerNumber</sub></span></p>
<p><span class="math inline">⟦sqrt(<em>e</em>)⟧<sub>AE</sub> = [√⟦<em>e</em>⟧<sub>AE</sub>]</span></p>
<p><span class="math inline">⟦ − <em>e</em>⟧<sub>AE</sub> =  − ⟦<em>e</em>⟧<sub>AE</sub></span></p>
<p><span class="math inline">⟦<em>e</em><sub>1</sub> <em>a</em><em>o</em><em>p</em> <em>e</em><sub>2</sub>⟧<sub>AE</sub> = ⟦<em>o</em><em>p</em>⟧<sub>AE-aop</sub>(⟦<em>e</em><sub>1</sub>⟧<sub>AE</sub>, ⟦<em>e</em><sub>2</sub>⟧<sub>AE</sub>)</span> [e.g.&nbsp;<span class="math inline">⟦<code></code>⟧<sub>AE-aop</sub> = mod</span>]</p>
</div>
</section><div><a class="slider-prev" href="#imp-programs"></a><a class="slider-next" href="#naive-denotational-semantics-1"></a></div>
<section id="naive-denotational-semantics-1" class="slide level1">
<h1>Naive denotational semantics</h1>
<h2 id="boolean-expression-semantics">Boolean expression semantics</h2>
<p>abop — arithmetical-boolean operator, bbop — boolean-boolean operator.</p>
<p><span class="math inline">⟦ · ⟧<sub>BE</sub> : BooleanExpression → Bool</span></p>
<p><span class="math inline">⟦<em>e</em><sub>1</sub> <em>a</em><em>b</em><em>o</em><em>p</em> <em>e</em><sub>2</sub>⟧<sub>BE</sub> = ⟦<em>a</em><em>b</em><em>o</em><em>p</em>⟧(⟦<em>e</em><sub>1</sub>⟧<sub>AE</sub>, ⟦<em>e</em><sub>2</sub>⟧<sub>AE</sub>)</span></p>
<p><span class="math inline">⟦<code>!</code><em>b</em>⟧<sub>BE</sub> = ¬⟦<em>b</em>⟧</span></p>
<p><span class="math inline">⟦<em>b</em><sub>1</sub> <em>b</em><em>b</em><em>o</em><em>p</em> <em>b</em><sub>2</sub>⟧<sub>BE</sub> = ⟦<em>b</em><em>b</em><em>o</em><em>p</em>⟧(⟦<em>b</em><sub>1</sub>⟧<sub>BE</sub>, ⟦<em>b</em><sub>2</sub>⟧<sub>BE</sub>)</span></p>
</section><div><a class="slider-prev" href="#naive-denotational-semantics"></a><a class="slider-next" href="#environments"></a></div>
<section id="environments" class="slide level1">
<h1>Environments</h1>
<p>Expressions have read-only access to variables. It is represented in terms of environment (additional argument to the meaning function).</p>
<p><strong>Semantic domain:</strong> <em>VariableState ≡ Identifier → Int<span class="math inline"><sub>⟂</sub></span>,</em> <em>Int<span class="math inline"><sub>⟂</sub></span> = Int ∪ { ⟂ }</em> with bottom (⟂) value representing undefined variable state. We will discuss this construction later, for now let us just state that <span class="math inline"><em>f</em>(<em>x</em>, ⊥) = <em>f</em>(⟂,<em>x</em>) = ⟂</span> for all defined functions.</p>
<p>Update meaning functions:</p>
<p><span class="math inline">⟦ · ⟧<sub>AE</sub> : VariableState → ArithmeticalExpression → Int<sub>⟂</sub></span></p>
<p>All previously defined cases are updated to pass an environment to nested functions, for example:</p>
<p>⟦ –e ⟧ = λ env . – ⟦e⟧(env)</p>
<p>Now we can define the variable getter expression: ⟦ Identifier(I) ⟧ = λ env. env(I)</p>
<p>Boolean expressions also depend on variable values. Previously defined cases must me updated.</p>
<p><span class="math inline">⟦ · ⟧<sub>BE</sub> : VariableState→BooleanExpression → Bool<sub>⟂</sub></span></p>
</section><div><a class="slider-prev" href="#naive-denotational-semantics-1"></a><a class="slider-next" href="#exceptions"></a></div>
<section id="exceptions" class="slide level1">
<h1>Exceptions</h1>
<div class="twocolumn">
<p>Remember that we have three operators (<code>/, %, sqrt</code>) which are not universally defined over the integer numbers.</p>
<p><strong>Convenience function:</strong></p>
<p>withLeft : (f : X → Y) → X + Error → Y + Error</p>
<p>withLeft(f, x) = <strong>match</strong>(x)</p>
<p>▷ <em>inl</em> a ↦ f(a)</p>
<p>▷ <em>inr</em> e ↦ e</p>
<p><strong>end</strong></p>
<p><strong>Semantic domains:</strong></p>
<ul>
<li class="fragment">errors: <em>Error = { div-by-zero, sqrt-from-negative }</em></li>
<li class="fragment">domain sum constructor: <em>X + Error</em> are the values of either <em>X</em> or <em>Error</em>, with constructor <em>inl</em> converting <em>X</em> values to sum, constructor <em>inr</em> converting <em>Error</em> values to the sum.</li>
</ul>
<p><strong>Meaning functions:</strong></p>
<p><span class="math inline">⟦ · ⟧<sub>AE</sub> : VariableState → ArithmeticalExpression → Int<sub>⟂</sub> + Error</span></p>
<p><span class="math inline">⟦ · ⟧<sub>BE</sub> : VariableState → BooleanExpression → Bool<sub>⟂</sub> + Error</span></p>
<p><strong>Example meaning function update:</strong></p>
<p>⟦ –e ⟧ = λ env . withLeft(λ x. –x, ⟦e⟧(env))</p>
</div>
</section><div><a class="slider-prev" href="#environments"></a><a class="slider-next" href="#statement-and-program-semantics"></a></div>
<section id="statement-and-program-semantics" class="slide level1">
<h1>Statement and program semantics</h1>
<h2 id="program">Program</h2>
<p>— receive the arguments and run statements. If statements computed without an error, get the return value.</p>
<p><span class="math inline">⟦ · ⟧<sub>P</sub> : VariableState → Int<sub>⊥</sub> + Error</span></p>
<p><span class="math inline">⟦<em>s</em><sub>1</sub>; <code>return</code> <em>I</em>⟧ = <em>λ</em><em>a</em><em>r</em><em>g</em><em>s</em>.withLeft(<em>λ</em><em>e</em><em>n</em><em>v</em>.<em>e</em><em>n</em><em>v</em>(<em>I</em>), ⟦<em>s</em><sub>1</sub>⟧(<em>a</em><em>r</em><em>g</em><em>s</em>))</span></p>
<h2 id="statement">Statement</h2>
<p>Statements manipulate the variable environment not as a read-only environment, but as a read-write state.</p>
<p><span class="math inline">⟦ · ⟧<sub>S</sub> : VariableState → VariableState + Error</span></p>
<p>⟦ <code>skip</code> ⟧ = λ env. inl(env)</p>
<p>⟦ s₁ <code>;</code> s₂ ⟧ = λ env. withLeft(⟦s₂⟧, ⟦s₁⟧(env))</p>
<p>⟦ I <code>=</code> e ⟧ = λ env. withLeft(λ i. (λ J. if J=I return i else return env(J)), ⟦e⟧(env))</p>
</section><div><a class="slider-prev" href="#exceptions"></a><a class="slider-next" href="#statements-2"></a></div>
<section id="statements-2" class="slide level1">
<h1>Statements (2)</h1>
<p>Let us adopt two shorthand notations for withLeft:</p>
<ul>
<li class="fragment"><p>left composition: x &gt;&gt;= y ≡ withLeft(y, x)</p></li>
<li class="fragment"><p>left variable binding: a ← b; S ≡ withLeft(λa. S, b)</p></li>
</ul>
<p><span class="math inline">⟦<code>if</code> <em>b</em><sub>1</sub> <em>s</em><sub><em>t</em></sub> <em>s</em><sub><em>f</em></sub>⟧ = <em>λ</em><em>e</em><em>n</em><em>v</em>.<em>b</em>′ ← ⟦<em>b</em><sub>1</sub>⟧(<em>e</em><em>n</em><em>v</em>);</span></p>
<p><span class="math inline">  </span> <strong>if</strong> <span class="math inline">(<em>b</em>′=<sub>Bool</sub>true)</span> <span class="math inline">⟦<em>s</em><sub><em>t</em></sub>⟧(<em>e</em><em>n</em><em>v</em>)</span></p>
<p><span class="math inline">  </span> <strong>else</strong> <span class="math inline">⟦<em>s</em><sub><em>f</em></sub>⟧(<em>e</em><em>n</em><em>v</em>)</span></p>
</section><div><a class="slider-prev" href="#statement-and-program-semantics"></a><a class="slider-next" href="#independent-execution-branches-in-legacy-code-with-automated-static-analysis-tools"></a></div>
<section id="independent-execution-branches-in-legacy-code-with-automated-static-analysis-tools" class="slide level1">
<h1>Independent execution branches in legacy code with automated static analysis tools</h1>
<h2 id="example-application-of-denotational-semantics">Example application of denotational semantics</h2>
</section><div><a class="slider-prev" href="#statements-2"></a><a class="slider-next" href="#task"></a></div>
<section id="task" class="slide level1">
<h1>Task</h1>
<p>Transform the existing legacy single-dimensional thermal-hydraulics code. Code is written in Fortran, memory is statically distributed.</p>
<p>Prove the correctness of the parallel execution.</p>
</section><div><a class="slider-prev" href="#independent-execution-branches-in-legacy-code-with-automated-static-analysis-tools"></a><a class="slider-next" href="#scheme-of-the-solution"></a></div>
<section id="scheme-of-the-solution" class="slide level1">
<h1>Scheme of the solution</h1>
<ol type="1">
<li class="fragment">Describe the formal semantics of the code.</li>
<li class="fragment">Expand the non-trivial syntactic constructions (partial evaluation).</li>
<li class="fragment">Transform the code to the static single assignment form (SSA).</li>
<li class="fragment">Define the dynamic semantics of code (in terms of substitution).</li>
<li class="fragment">Transform code to the model of dynamical concurrent exection.</li>
<li class="fragment">Show the correctness of the transformation (abstract interpretation).</li>
<li class="fragment">Schedule tasks statically.</li>
</ol>
</section><div><a class="slider-prev" href="#task"></a><a class="slider-next" href="#code-structure"></a></div>
<section id="code-structure" class="slide level1">
<h1>Code structure</h1>
<p>Thermal-hydraulics system model is a graph with differently-typed nodes (pipes, pumps, etc.). Objects have different properties (pressure, temperature). All properties of the same type are stored in separate array. Arrays are mapped to common blocks to synchronize with external modules of the whole system.</p>
<p>Code is generated automatically based on thermal-hydraulical system model. Main function consists of the sequence of stages, each stage is repeated for each of 7 subsystems which compute the updated values for some related parameter groups, in separate lines of code for each object.</p>
<p>Mapping of variables to common blocks is specified in header files.</p>
<p>In total for a real model (about 2000 objects) there are 424 000 lines of code in subset of Fortran.</p>
</section><div><a class="slider-prev" href="#scheme-of-the-solution"></a><a class="slider-next" href="#previous-work"></a></div>
<section id="previous-work" class="slide level1">
<h1>Previous work</h1>
<ul>
<li class="fragment">we tried running computations for each subsystem in separate process</li>
<li class="fragment">for each stage and for each subsystem we select memory blocks which are read and written at that stage</li>
<li class="fragment">before each stage processes synchronize required block values</li>
</ul>
<p>Result: subsystems are coarse-grained, stages are fine-grained with data dependencies at subsystem boundaries, almost no improvement in parallel distributed execution mode.</p>
</section><div><a class="slider-prev" href="#code-structure"></a><a class="slider-next" href="#fortran-subset-syntax"></a></div>
<section id="fortran-subset-syntax" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="header-files">Header files</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">CHARACTER*1</span> G03th_z1</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">COMMON/</span>global03th_z1<span class="kw">/</span>G03th_z1(<span class="dv">0</span>:<span class="dv">819199</span>)</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="dt">CHARACTER*1</span> G14</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">COMMON/</span>global14<span class="kw">/</span>G14(<span class="dv">0</span>:<span class="dv">3276799</span>)</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="dt">CHARACTER*1</span> G04th_z1</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">COMMON/</span>global04th_z1<span class="kw">/</span>G04th_z1(<span class="dv">0</span>:<span class="dv">819199</span>)</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="dt">CHARACTER*1</span> G15_z1</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">COMMON/</span>global15_z1<span class="kw">/</span>G15_z1(<span class="dv">0</span>:<span class="dv">1638399</span>)</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="dt">REAL*8</span>    chkfim</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="kw">EQUIVALENCE</span> (chkfim,G14(<span class="dv">46632</span>))</a>
<a class="sourceLine" id="cb4-11" title="11"><span class="dt">LOGICAL</span><span class="kw">*</span><span class="dv">1</span> th_pumpcav_<span class="dv">1</span>(<span class="dv">4</span>) </a>
<a class="sourceLine" id="cb4-12" title="12"><span class="kw">EQUIVALENCE</span> (th_pumpcav_<span class="dv">1</span>,G03th_z1(<span class="dv">78992</span>))</a>
<a class="sourceLine" id="cb4-13" title="13"><span class="dt">REAL*8</span>    thdfpp1_<span class="dv">1</span>(<span class="dv">563</span>,<span class="dv">2</span>) </a>
<a class="sourceLine" id="cb4-14" title="14"><span class="kw">EQUIVALENCE</span> (thdfpp1_<span class="dv">1</span>,G15_z1(<span class="dv">686920</span>))</a></code></pre></div>
</section><div><a class="slider-prev" href="#previous-work"></a><a class="slider-next" href="#fortran-subset-syntax-1"></a></div>
<section id="fortran-subset-syntax-1" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="header-files-1">Header files</h2>
<pre><code>&lt;head&gt; ::= (&lt;head_decl&gt; | &lt;head_comm&gt; | &lt;head_equiv&gt;)+ ;

// Variable declaration:
&lt;head_decl&gt; ::= &lt;type&gt; &lt;identifier&gt; &lt;length&gt;?;

// Common block declaration:
&lt;head_comm&gt; ::= "COMMON/" &lt;identifier&gt; ("/" &lt;identifier&gt;)* 
    "(" &lt;positiveLiteral&gt; ":" &lt;positiveLiteral&gt; ")";

// Variable mapping
&lt;head_equiv&gt; ::= "EQUIVALENCE" "(" &lt;identifier&gt; "," &lt;identifier&gt;" "(" &lt;positiveLiteral&gt; ")" ")"

&lt;type&gt; ::= 
      "CHARACTER" "*" &lt;positiveLiteral&gt; 
    | "REAL" "*" &lt;positiveLiteral&gt;
    | "INTEGER" "*" &lt;positiveLiteral&gt;
    | "LOGICAL" "*" &lt;positiveLiteral&gt;</code></pre>
</section><div><a class="slider-prev" href="#fortran-subset-syntax"></a><a class="slider-next" href="#fortran-subset-syntax-2"></a></div>
<section id="fortran-subset-syntax-2" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="source-code-files">Source code files</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">1</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,</a>
<a class="sourceLine" id="cb6-2" title="2">     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, </a>
<a class="sourceLine" id="cb6-3" title="3">     y1mtmp(<span class="dv">862</span> ), y1mtmp( <span class="dv">863</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1054</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, </a>
<a class="sourceLine" id="cb6-4" title="4">     <span class="kw">-</span> y1mtmp( <span class="dv">1055</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">13</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">14</span> ),</a>
<a class="sourceLine" id="cb6-5" title="5">     fwdlpnt_<span class="dv">1</span>( <span class="dv">13</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">14</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">1</span> ), fwfipp2_<span class="dv">1</span>(<span class="dv">1</span> ), </a>
<a class="sourceLine" id="cb6-6" title="6">     fwfpntpnt1_<span class="dv">1</span>( <span class="dv">1</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">1</span> ), fwpflowpp_<span class="dv">1</span>,</a>
<a class="sourceLine" id="cb6-7" title="7">     fwzpp_<span class="dv">1</span>( <span class="dv">1</span> ), fwdtt_<span class="dv">1</span>, kf0 )</a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">2</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,</a>
<a class="sourceLine" id="cb6-10" title="10">     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, </a>
<a class="sourceLine" id="cb6-11" title="11">     y1mtmp(     <span class="dv">863</span> ), y1mtmp( <span class="dv">864</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1055</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, </a>
<a class="sourceLine" id="cb6-12" title="12">     <span class="kw">-</span> y1mtmp(     <span class="dv">1056</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">14</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">15</span> ),     </a>
<a class="sourceLine" id="cb6-13" title="13">     fwdlpnt_<span class="dv">1</span>( <span class="dv">14</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">15</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">2</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">2</span> ), </a>
<a class="sourceLine" id="cb6-14" title="14">     fwfpntpnt1_<span class="dv">1</span>( <span class="dv">2</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">2</span> ), fwpflowpp_<span class="dv">1</span>,     </a>
<a class="sourceLine" id="cb6-15" title="15">     fwzpp_<span class="dv">1</span>( <span class="dv">2</span> ), fwdtt_<span class="dv">1</span>, kf0 )</a>
<a class="sourceLine" id="cb6-16" title="16"></a>
<a class="sourceLine" id="cb6-17" title="17"><span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">3</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,</a>
<a class="sourceLine" id="cb6-18" title="18">     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, </a>
<a class="sourceLine" id="cb6-19" title="19">     y1mtmp(     <span class="dv">850</span> ), y1mtmp( <span class="dv">851</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1042</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, </a>
<a class="sourceLine" id="cb6-20" title="20">     <span class="kw">-</span> y1mtmp(     <span class="dv">1043</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">1</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">2</span> ),     </a>
<a class="sourceLine" id="cb6-21" title="21">     fwdlpnt_<span class="dv">1</span>( <span class="dv">1</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">2</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">3</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">3</span> ), </a>
<a class="sourceLine" id="cb6-22" title="22">     fwfpntpnt1_<span class="dv">1</span>( <span class="dv">3</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">3</span> ), fwpflowpp_<span class="dv">1</span>,     </a>
<a class="sourceLine" id="cb6-23" title="23">     fwzpp_<span class="dv">1</span>( <span class="dv">3</span> ), fwdtt_<span class="dv">1</span>, kf0 )</a>
<a class="sourceLine" id="cb6-24" title="24"></a>
<a class="sourceLine" id="cb6-25" title="25"><span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">4</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">852</span> ), y1mtmp( <span class="dv">853</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1044</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1045</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">3</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">4</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">3</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">4</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">4</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">4</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">4</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">4</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">4</span> ), fwdtt_<span class="dv">1</span>, kf0 )</a>
<a class="sourceLine" id="cb6-26" title="26"></a>
<a class="sourceLine" id="cb6-27" title="27"><span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">5</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">851</span> ), y1mtmp( <span class="dv">854</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1043</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1046</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">2</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">5</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">2</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">5</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">5</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">5</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">5</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">5</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">5</span> ), fwdtt_<span class="dv">1</span>, kf0 )</a>
<a class="sourceLine" id="cb6-28" title="28"></a>
<a class="sourceLine" id="cb6-29" title="29"><span class="kw">CALL</span> ysfpp5t( <span class="dv">202</span>, <span class="dv">6</span>, fwpflowppv_<span class="dv">1</span>, fwfpp1_<span class="dv">1</span>, fwfpp2_<span class="dv">1</span>,     fwdfpp1_<span class="dv">1</span>, fwdfpp2_<span class="dv">1</span>, fwdfpp1_fi_<span class="dv">1</span>, fwdfpp2_fi_<span class="dv">1</span>, y1mtmp(     <span class="dv">853</span> ), y1mtmp( <span class="dv">854</span> ), <span class="kw">-</span> y1mtmp( <span class="dv">1045</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, <span class="kw">-</span> y1mtmp(     <span class="dv">1046</span> ) <span class="kw">*</span> fwdtt_<span class="dv">1</span>, fwdvgpnt_<span class="dv">1</span>( <span class="dv">4</span> ), fwdvgpnt_<span class="dv">1</span>( <span class="dv">5</span> ),     fwdlpnt_<span class="dv">1</span>( <span class="dv">4</span> ), fwdlpnt_<span class="dv">1</span>( <span class="dv">5</span> ), fwfipp1_<span class="dv">1</span>( <span class="dv">6</span> ), fwfipp2_<span class="dv">1</span>(     <span class="dv">6</span> ), fwfpntpnt1_<span class="dv">1</span>( <span class="dv">6</span> ), fwfpntpnt2_<span class="dv">1</span>( <span class="dv">6</span> ), fwpflowpp_<span class="dv">1</span>,     fwzpp_<span class="dv">1</span>( <span class="dv">6</span> ), fwdtt_<span class="dv">1</span>, kf0 )</a></code></pre></div>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-1"></a><a class="slider-next" href="#fortran-subset-syntax-3"></a></div>
<section id="fortran-subset-syntax-3" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="source-code">Source code</h2>
<pre><code>&lt;program&gt; ::= &lt;header&gt; &lt;include&gt; &lt;preliminary&gt;* &lt;statements&gt; "END"

&lt;header&gt; ::= ("SUBROUTINE" | "FUNCTION") identifier ("(" &lt;identifiers&gt; ")")?
&lt;include&gt; ::= "INCLUDE" "'" &lt;identifier&gt; ".h'"
&lt;preliminary&gt; ::= &lt;type&gt; &lt;declarators&gt; | "DATA" &lt;dataDeclarators&gt;

&lt;statements&gt; ::= &lt;statement&gt; &lt;statement&gt;*;
&lt;statement&gt; ::=
    &lt;lvalue&gt; "=" &lt;expression&gt; 
    | &lt;positiveLiteral&gt; "CONTINUE" 
    | "CALL" &lt;identifier&gt; "(" &lt;expressions&gt; ")"
    | "IF" "(" &lt;expression&gt; ")" "THEN"? &lt;statements&gt;
        ("ELSE" "IF" "(" &lt;expression&gt; ")" "THEN" &lt;statements&gt; )*
        ("ELSE" &lt;statements&gt;)?
        "END IF"
    | "DO" &lt;identifier&gt; = &lt;expression&gt; "," &lt;expression&gt; ("," &lt;integerLiteral&gt;)?
        &lt;statements&gt;
      "END DO"
    | "DO" "WHILE" "(" &lt;expression&gt; ")" &lt;statements&gt; "END" "DO"
    | "RETURN"
</code></pre>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-2"></a><a class="slider-next" href="#fortran-subset-syntax-4"></a></div>
<section id="fortran-subset-syntax-4" class="slide level1">
<h1>Fortran subset syntax</h1>
<h2 id="source-code-1">Source code</h2>
<p>Infix operators priority is irrelevant in our dynamical semantics models.</p>
<pre><code>&lt;lvalue&gt; ::= &lt;identifier&gt; ("(" &lt;expressions&gt; ")")?
&lt;expression&gt; ::= 
      &lt;simple_expression&gt; &lt;binop&gt; &lt;expression&gt; 
    | &lt;simple_expression&gt;

&lt;binop&gt; ::= ".EQ." | ".NE." | ".GE." | ".LE." | ".LT." | ".GT." | ".AND." | ".OR." 
    | "+" | "-" | "/" | "**" | "*"

&lt;unop&gt; ::= ".NOT." | "-"

&lt;simple_expression&gt; ::=
    "(" &lt;expression&gt; ")"
    | &lt;literal&gt;
    | &lt;identifier&gt;
    | &lt;identifier&gt; "(" &lt;expressions&gt; ")"
    | &lt;identifier&gt; "(" ")"
    | &lt;unop&gt; &lt;expression&gt;</code></pre>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-3"></a><a class="slider-next" href="#model-of-dynamical-concurrent-program-execution"></a></div>
<section id="model-of-dynamical-concurrent-program-execution" class="slide level1">
<h1>Model of dynamical concurrent program execution</h1>
<p>Modifier (extension) of static and dynamic denotational semantics for the existing programming languages.</p>
<p>Statements =</p>
<ul>
<li class="fragment"><code>compute</code> c</li>
<li class="fragment">s<span class="math inline"><sub>1</sub></span> <code>;</code> s<span class="math inline"><sub>2</sub></span></li>
<li class="fragment">v = <code>spawn</code> t, c</li>
<li class="fragment"><code>wait</code> v, m</li>
</ul>
<p>Requirement: computations are purely functional (no global modifiable state)</p>
<p>Property (theorem): correctness of the parallel execution.</p>
<p>Vasenin V. A., Krivchikov M. A. A model of dynamical concurrent program execution // Programming and Computer Software. — 2013. — Vol. 39, no. 1. — P. 1–9.</p>
</section><div><a class="slider-prev" href="#fortran-subset-syntax-4"></a><a class="slider-next" href="#fortran-subset-static-formal-semantics"></a></div>
<section id="fortran-subset-static-formal-semantics" class="slide level1">
<h1>Fortran subset static formal semantics</h1>
<p>Identifiers are uniquely mapped to the block in which it is mapped.</p>
<p>Location : identifier → MemoryBlock × Offset × Size</p>
<p>Memory blocks are annotated with non-negative number (version). Version is increased at the time of the assignment.</p>
<p>Classical intermediate representation: SSA (static single assignment form).</p>
<p>SSA defines mutable variables as a sequence of immutable values.</p>
<p>Version : MemoryBlock × Offset × Size → N</p>
<p>Local variables may be represented in terms of the separate memory block.</p>
</section><div><a class="slider-prev" href="#model-of-dynamical-concurrent-program-execution"></a><a class="slider-next" href="#static-formal-semantics-transformation"></a></div>
<section id="static-formal-semantics-transformation" class="slide level1">
<h1>Static formal semantics transformation</h1>
<ol type="1">
<li class="fragment">Replace function calls with function code, substitute arguments, allocate memory for local variables. Simple functions can be replaced by “multiple-assignment” operators with special functional symbols.</li>
<li class="fragment">Unroll <code>DO</code> loops with constant boundaries.</li>
<li class="fragment">Replace <code>DO WHILE</code> loops and <code>IF</code> conditional operators with “multiple-assignment” operators.</li>
<li class="fragment">Replace identifiers with triples MemoryBlock × Offset × N</li>
</ol>
<p>I₁ = f(I₂, …, Iₙ)</p>
<p>(Location I₁, Version (Location I₁)+1) := f((Location I₂, Version(Location I₂)), …,</p>
<p>(Location Iₙ, Version(Location Iₙ)))</p>
<p>Version[Location I₁] ← Version[Location I₁] + 1</p>
<p>Local variables are stored in separate memory block.</p>
</section><div><a class="slider-prev" href="#fortran-subset-static-formal-semantics"></a><a class="slider-next" href="#static-formal-semantics"></a></div>
<section id="static-formal-semantics" class="slide level1">
<h1>Static formal semantics</h1>
<h2 id="operator-of-multiple-assignment-and-special-functional-symbol">Operator of multiple assignment and special functional symbol</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">IF</span> ( f_temp1 <span class="op">.GT.</span> thhgconv ) <span class="kw">THEN</span></a>
<a class="sourceLine" id="cb9-2" title="2">    htcarg1 <span class="kw">=</span> f_temp1 <span class="kw">*</span> fipnt <span class="kw">+</span> thhgconv <span class="kw">*</span> ( kf1 <span class="kw">-</span> fipnt )</a>
<a class="sourceLine" id="cb9-3" title="3">    mode <span class="kw">=</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">ELSE</span></a>
<a class="sourceLine" id="cb9-5" title="5">    htcarg1 <span class="kw">=</span> thhgconv</a>
<a class="sourceLine" id="cb9-6" title="6">    mode <span class="kw">=</span> <span class="dv">15</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">END IF</span></a></code></pre></div>
<p>(htcarg1, mode) = IF1234(f_temp1, thhgconv, fipnt, kf1)</p>
</section><div><a class="slider-prev" href="#static-formal-semantics-transformation"></a><a class="slider-next" href="#dynamic-semantics"></a></div>
<section id="dynamic-semantics" class="slide level1">
<h1>Dynamic semantics</h1>
<p>specified by means of symbolic substitution:</p>
<p>In result of static semantics transformation program is converted into sequence of multiple-assignment operators with expressions or functional symbols in the right part.</p>
<p>Dynamic semantics environment stores static semantics representation of <em>expressions</em> (symbolic computation):</p>
<p>I₁ = (G₁, O₁, V₁) := f₁(…) … Iₙ = (Gₙ, Oₙ, Vₙ) := fₙ(…)</p>
<p>⟦J = (Gⱼ, Oⱼ, Vⱼ) := g(I₁, …, Iₙ)⟧ ≡ J = (Gⱼ, Oⱼ, Vⱼ) := g(f₁(…), …, fₙ(…))</p>
</section><div><a class="slider-prev" href="#static-formal-semantics"></a><a class="slider-next" href="#independent-computation-branches"></a></div>
<section id="independent-computation-branches" class="slide level1">
<h1>Independent computation branches</h1>
<p>Independent computation branches are separated by means of representing assignment operators and variable dereference in terms of dynamic concurrent program execution model.</p>
<p>Each assignment operator is executed in separate logical computation thread.</p>
<p>Dynamic semantics environment for each version of memory block location stores an identifier for the thread and index of the result in multiple-assignment.</p>
<p>I₁ = (G₁, O₁, V₁) := T₁, k₁</p>
<p>…</p>
<p>Iₙ = (Gₙ, Oₙ, Vₙ) := Tₙ, kₙ</p>
<p>⟦J = (Gⱼ, Oⱼ, Vⱼ) := g(I₁, …, Iₙ)⟧ ≡</p>
<p>J = (Gⱼ, Oⱼ, Vⱼ) := spawn g [ I₁ := wait T₁, k₁; …; Iₙ := wait Tₙ, kₙ ]</p>
<p>Equivalence between original dynamic semantics and concurrent dynamic semantics is checked directly with sequential execution mode. Resulting expressions for all memory locations must be the same for non-concurrent dynamic semantics and concurrent dynamic semantics in sequential mode.</p>
</section><div><a class="slider-prev" href="#dynamic-semantics"></a><a class="slider-next" href="#static-scheduling"></a></div>
<section id="static-scheduling" class="slide level1">
<h1>Static scheduling</h1>
<p>In contrast with previous approach, parallel execution in this case is fine-grained. Because target system is distributed as a complete technological platform, we can use static thread scheduling:</p>
<p>Dynamical concurrent execution model runs before compiling; core of the model provides static scheduler.</p>
<p>In terms of static semantics for each statement we assign an index of parallel process.</p>
<p>Depending on the used concurrent execution implementation, “spawn” and “wait” statements are translated to the sequence of implementation-specific functions.</p>
</section><div><a class="slider-prev" href="#independent-computation-branches"></a><a class="slider-next" href="#cost-model"></a></div>
<section id="cost-model" class="slide level1">
<h1>Cost model</h1>
<p>To schedule threads effectively we need the additional information on the expected operation timings.</p>
<p>Model parameters:</p>
<ol type="1">
<li class="fragment">Binary and unary numeric operation cost.</li>
<li class="fragment">Functional symbol cost (upper bound on loop body cost).</li>
<li class="fragment">Cost of data transfer (only if data transfer is required).</li>
</ol>
<p>Scheduler environment contains mapping between (physical) processes and (logical) computation threads.</p>
<pre><code>ComputationCost : Computation → N
MessageCost : Schedule × TId × TId → N
Cost(S, J = (Gⱼ, Oⱼ, Vⱼ) := spawn g [ I₁ := wait T₁, k₁, ..., Iₙ := wait Tₙ, kₙ  ]) 
    = ComputationCost(g) 
    + Σᵢ MessageCost(g, Tᵢ)</code></pre>
<p>Optimal mapping problem is NP-hard, it is impossible to find true optimal solution in practice. But practice doesn’t require optimal solution, “fast enough” is enough.</p>
</section><div><a class="slider-prev" href="#static-scheduling"></a><a class="slider-next" href="#examples"></a></div>
<section id="examples" class="slide level1">
<h1>Examples</h1>
<h2 id="sequential-execution-baseline">Sequential execution (baseline)</h2>
<ol type="1">
<li class="fragment">Binary and unary operation const — 1.</li>
<li class="fragment">Functional symbol cost — computed.</li>
<li class="fragment">Data transfer cost — 0.</li>
</ol>
<p>Number of processes = 1</p>
<h2 id="mpi">MPI</h2>
<ol type="1">
<li class="fragment">Binary and unary operation cost — 1.</li>
<li class="fragment">Functional symbol cost — computed.</li>
<li class="fragment">Data transfer cost — 1000 (mpi_ping on customer hardware)</li>
</ol>
<p>Number of processes = 2..48 (customer hardware)</p>
<h2 id="threads">Threads</h2>
<ol type="1">
<li class="fragment">Binary and unary operation cost — 1.</li>
<li class="fragment">Functional symbol cost — computed.</li>
<li class="fragment">Data transfer cost — 1.</li>
</ol>
<p>Number of processes = 2..60 (Xeon Phi)</p>
</section><div><a class="slider-prev" href="#cost-model"></a><a class="slider-next" href="#malt"></a></div>
<section id="malt" class="slide level1">
<h1>MALT</h1>
<p>future many-core CPU architecture, developed at Faculty of Physics, Lomonosov Moscow State University, in cooperation with NII Kvant.</p>
<ul>
<li class="fragment">hardware support of featherweight threads (F/E bits)</li>
<li class="fragment">no hardware floating-point unit</li>
<li class="fragment">costs are my speculative assumptions based on workshop reports of developers</li>
</ul>
<ol type="1">
<li class="fragment">Binary and unary operation cost — 1..200 (SoftFloat).</li>
<li class="fragment">Functional symbol cost — computed.</li>
<li class="fragment">Data transfer cost — 1.</li>
</ol>
<p>Number of processes: ~100-1000.</p>
<p>Hypotheses: overhead of software-emulated floating point operation is compensated by high level of parallelism and low cost of data transfer</p>
</section><div><a class="slider-prev" href="#examples"></a><a class="slider-next" href="#future-work-directions"></a></div>
<section id="future-work-directions" class="slide level1">
<h1>Future work directions</h1>
<ul>
<li class="fragment">pack consequtive data transfers (MessageCost : Schedule × TId × TId × Size → N = C + k*Size)</li>
<li class="fragment">add SIMD operations into cost model</li>
<li class="fragment">local microoptimization and postoptimization for code</li>
<li class="fragment">implement scheduling algorithm and run simulations</li>
</ul>
</section><div><a class="slider-prev" href="#malt"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  function handleKeydown(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 33: // Page Up
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 34: // Page Down
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  }
  document.addEventListener("keydown", handleKeydown);
  document.getElementById("flat-view").addEventListener("click", function(e) {
    document.getElementById("main").classList.toggle('slider');
    if (document.getElementById("main").classList.contains('slider')) {
      document.getElementById("container").style="width: 640px;height: 400px;";
      document.addEventListener("keydown", handleKeydown);
    } else {
      document.getElementById("container").style="";
      document.removeEventListener("keydown", handleKeydown);
    }
  })
  </script>
  

</body></html>
