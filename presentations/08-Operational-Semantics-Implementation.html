<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
  <link rel="stylesheet" href="reveal.js/css/theme/maxxk.css" id="theme">
  <link rel="stylesheet" href="additional.css"/>
  <link rel="stylesheet" href="reveal.js/css/highlight-github.css"/>
  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if( window.location.search.match( /print-pdf/gi ) ) {
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'reveal.js/css/print/pdf.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<style type="text/css">.reveal pre code{white-space: pre; font-size: 1.5em; line-height: 1.3;}
.reveal abbr { border-bottom: 0.1pt dashed blue;}
</style>

</head>
<body>
  <div class="reveal">
    <div class="slides">


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="mechanized-semantics">Mechanized semantics</h2>
<h3 id="monads-and-monad-transformers">Monads and Monad Transformers</h3>
<h2 id="implementation-of-operational-semantics">Implementation of operational semantics</h2>
<h3 id="compcert-verified-c-compiler">CompCert verified C compiler</h3>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: small !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
.reveal section {
  text-align: left;
}
</style>
<p>Course page: <a href="https://maxxk.github.io/programming-languages-2016/" class="uri">https://maxxk.github.io/programming-languages-2016/</a><br />
Contact author: <script type="text/javascript">
<!--
h='&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#x6d;&#x61;&#120;&#x69;&#x6d;&#46;&#x6b;&#114;&#x69;&#118;&#x63;&#104;&#x69;&#x6b;&#x6f;&#118;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x6d;&#x61;&#120;&#x69;&#x6d;&#46;&#x6b;&#114;&#x69;&#118;&#x63;&#104;&#x69;&#x6b;&#x6f;&#118;&#32;&#x61;&#116;&#32;&#x67;&#x6d;&#x61;&#x69;&#108;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;</noscript></p>
</section>
<section id="mechanized-semantics-for-the-clight-subset-of-the-c-language" class="slide level1">
<h1>Mechanized Semantics for the Clight Subset of the C Language</h1>
<div class="small">
Blazy S., Leroy X. Mechanized Semantics for the Clight Subset of the C Language // Journal of Automated Reasoning. 2009. Vol. 43, № 3. P. 263–288. <a href="http://dx.doi.org/10.1007/s10817-009-9148-3" class="uri">http://dx.doi.org/10.1007/s10817-009-9148-3</a>
</div>
<p>Big-step operational semantics for a subset of the C programming language. Implemented in Coq for CompCert certifying C compiler.</p>
<p>Links:</p>
<ol type="1">
<li>Official site: <a href="http://compcert.inria.fr/" class="uri">http://compcert.inria.fr/</a></li>
<li>Source code repository: <a href="https://github.com/AbsInt/CompCert" class="uri">https://github.com/AbsInt/CompCert</a> (non-free software, see license: <a href="https://github.com/AbsInt/CompCert/blob/master/LICENSE" class="uri">https://github.com/AbsInt/CompCert/blob/master/LICENSE</a>)</li>
<li>Complete commented (literate) Coq source code: <a href="http://compcert.inria.fr/doc/index.html" class="uri">http://compcert.inria.fr/doc/index.html</a></li>
<li>Full source code for the article: <a href="http://compcert.inria.fr/doc/html/Clight.html" class="uri">http://compcert.inria.fr/doc/html/Clight.html</a></li>
</ol>
</section>
<section id="clight-language" class="slide level1">
<h1>Clight language</h1>
<p>— intermediate representation of C programs (source code in C is desugared into Clight).</p>
<ul>
<li>no concrete syntax (but for the sake of readability we sometimes will use C-like syntax)</li>
<li>no string literals (replaced with pointers to static data section)</li>
<li>all expressions are pure: assignment is a statement, increment/decrement operators are disabled etc. (behavior of some constructions, unspecified by the specification, is specified at the C → Clight translation stage, e.g. order of evaluation of function arguments)</li>
<li>all expressions are annotated with types</li>
<li>temporary variables are introduced</li>
<li>function call is a statement with result assigned to temporary variable</li>
<li><code>for</code>, <code>while</code> and <code>do ... while</code> loops are desugared into a single construction <code>loop &lt;first&gt; &lt;next&gt;</code></li>
</ul>
</section>
<section id="clight-abstract-syntax" class="slide level1">
<h1>Clight abstract syntax</h1>
<h2 id="expressions">Expressions</h2>
<p>Inductive expr : Type :=<br />
(* integer literal, e.g. <code>1234</code> *)<br />
| Econst_int : int → type → expr<br />
(* binary operation, e.g. <code>a+b</code> *)<br />
| Ebinop : binary_operation → expr → expr → type → expr<br />
(* type cast, e.g. <code>(float)x</code> *)<br />
| Ecast : expr → type → expr<br />
| …</p>
</section>
<section id="clight-abstract-syntax-1" class="slide level1">
<h1>Clight abstract syntax</h1>
<h2 id="statements">Statements</h2>
<p>Inductive statement : Type :=<br />
(* do nothing *)<br />
| Sskip : statement<br />
(* assignment <code>lvalue = rvalue</code>, lvalue may contain e.g. pointer arithmetics *)<br />
| Sassign : expr → expr → statement<br />
(* desugared loop *)<br />
| Sloop : statement → statement → statement<br />
| Sbreak : statement<br />
| Scontinue : statement<br />
| …</p>
</section>
<section id="clight-loop-desugaring" class="slide level1">
<h1>Clight loop desugaring</h1>
<pre><code>Definition Swhile (e: expr) (s: statement) :=
  Sloop (Ssequence (Sifthenelse e Sskip Sbreak) s) Sskip.

Definition Sdowhile (s: statement) (e: expr) :=
  Sloop s (Sifthenelse e Sskip Sbreak).

Definition Sfor (s1: statement) (e2: expr) (s3: statement) (s4: statement) :=
  Ssequence s1 (Sloop (Ssequence (Sifthenelse e2 Sskip Sbreak) s3) s4).</code></pre>
</section>
<section id="clight-static-semantics" class="slide level1">
<h1>Clight static semantics</h1>
<h2 id="global-environment">Global environment</h2>
<p>G maps names of functions and global variables to memory block references, and function pointers to their definitions.</p>
<h2 id="local-and-temporary-environments">Local and temporary environments</h2>
<p>The local environment E maps local variables to memory block references with types.<br />
The temporary environemnt maps local temporaries to values.</p>
</section>
<section id="clight-operational-semantics-overview" class="slide level1">
<h1>Clight operational semantics overview</h1>
<p>Big-step operational semantcs. 10 evaluation relations are defined:</p>
<ol type="1">
<li>G, E ⊦ a, M ⇐ L — evaluation of expressions in l-value position, i.e. targets of assignment</li>
<li>G, E ⊦ a, M ⇒ v — evaluation of expressions in r-value position</li>
<li>G, E ⊦ [a], M ⇒ [v] — evaluation of lists of expression, e.g. function call arguments</li>
<li>G, E ⊦ s, M ⇒ out, M' — evaluation of statements, terminating case, M and M' are memory states</li>
<li>G, E ⊦ sw, M ⇒ out, M' — execution of the <code>switch</code> cases</li>
<li>G ⊦ Fd([v]), M ⇒ v, M' — evaluation of function invocation, terminating case</li>
<li><p>G, E ⊦ s, M ⇒ ∞ — evaluation of statements, diverging case<br />
8, 9. — diverging evaluation of <code>switch</code> cases and function invocation</p></li>
<li><p>P ⇒ B — execution of the whole program</p></li>
</ol>
</section>
<section id="indexed-inductive-types" class="slide level1">
<h1>Indexed inductive types</h1>
<p>Simple inductive types — represented by a set of constructors, all values have same type (see expressions and statements above).<br />
Indexed inductive types — represented by a set of constructors and some index type. Each instance of indexed inductive type is a separate type.<br />
Example (from <a href="http://maxxk.github.io/formal-models-2015/pdf/08-Inductive.pdf">previous semester</a>):<br />
Even : ℕ → Type :=<br />
| even_zero : Even 0<br />
| even_plus_2 : forall (k : ℕ), Even(k) → Even(k+2)</p>
<p><em>Even 0,</em> <em>Even 2</em> and <em>Even 4</em> are of different types (but <em>Even 2</em> and <em>Even 4</em> are constructed by call of the same constructor <em>even_plus_2</em>).</p>
</section>
<section id="evaluation-relations-in-dependently-typed-specification-language" class="slide level1">
<h1>Evaluation relations in dependently-typed specification language</h1>
<p>Evaluation relations are defined as an indexed inductive type. It is common way of definition for possibly-undecidable relations.</p>
<p>Inductive eval_expr (G : global) (L : local) : expr → val → Type (* expr ⇒ val *)</p>
<p>Two indices:</p>
<ul>
<li><em>expr</em> — left hand side of relation</li>
<li><em>val</em> — right hand side of relation</li>
</ul>
<p>Individual judgements are represented as the constructors for the indexed inductive type.<br />
Axiom:<br />
| eval_Econst_int : forall (i : int, ty : Ctype), eval_expr (Econst_int i ty) (Vint i)<br />
Same judgement in different notation:<br />
G, E ⊦ Econst_int i ty ⇒ Vint i [eval_Econst_int]</p>
</section>
<section id="evaluation-relations" class="slide level1">
<h1>Evaluation relations</h1>
<p>Premises (antecedents) are represented as a constructor arguments:</p>
<p>Rule:</p>
<pre><code>| eval_Ebinop : forall op a1 a2 ty v1 v2 v,
    eval_expr a1 v1 →
    eval_expr a2 v2 →
    sem_binary_op G op v1 (typeof a1) v2 (typeof a2) m = Some v →
    eval_expr (Ebinop op a1 a2 ty) v</code></pre>
<p>Different notation:<br />
<span class="math display">\[\dfrac{\text{a1 ⇒ v1; a2 ⇒ v2; a1 `op` a2} ⇒_{\text{binop}} \text{v}}
{\text{[ty] a1 `op` a2 ⇒ v}} [\text{eval_Ebinop}]
\]</span></p>
<p><code>sem_binary_op</code> (binop) is a decidable relation, hence we may represent it as a function.</p>
</section>
<section id="expression-evaluation-and-static-semantics" class="slide level1">
<h1>Expression evaluation and static semantics</h1>
<p>We have environments G and E as a parameters, so we can use them in premises of definition.<br />
<code>expr</code> — relation left hand side;<br />
<code>block, int</code> — right hand side (memory block and offset)</p>
<pre><code>Inductive eval_lvalue (E : local) (G : global): expr → block → int → Prop :=
| eval_Evar_local : forall id  l  ty,
    E ! id = Some(l, ty) →
    eval_lvalue (Evar id ty) l Int.zero
| eval_Evar_global : forall id l ty,
    E ! id = None →
    Genv.find_symbol G id = Some l →
    eval_lvalue (Evar id ty) l Int.zero
| …</code></pre>
<p>Note that both <code>eval_Evar_local</code> and <code>eval_Evar_global</code> have the same left hand side but different premises.</p>
</section>
<section id="statement-evaluation" class="slide level1">
<h1>Statement evaluation</h1>
<h2 id="how-can-we-represent-the-evaluation-of-sequence-of-imperative-language-statements-in-pure-functional-programming-language">How can we represent the evaluation of sequence of imperative language statements in pure functional programming language?</h2>
</section>
<section id="continuations" class="slide level1">
<h1>Continuations</h1>
<p>Continuation is a representation of execution state of a program (for example, the call stack) at a certain point of time.<br />
Continuation may be understood as dynamic <code>goto</code> instruction. By using continuations we may jump between different places of a program preserving the context of each.</p>
</section>
<section id="continuations-in-practice" class="slide level1">
<h1>Continuations in practice</h1>
C# <code>async</code>/<code>await</code> asynchronous execution keywords.<br />
<img src="images/IC612215.png" /><br />

<div class="small">
Image source: <a href="https://msdn.microsoft.com/en-us/library/hh191443.aspx" class="uri">https://msdn.microsoft.com/en-us/library/hh191443.aspx</a>
</div>
</section>
<section id="continuations-for-clight-semantics" class="slide level1">
<h1>Continuations for Clight semantics</h1>
<pre><code>Inductive cont: Type :=
  | Kstop: cont
  (* Kseq s2 k = after s1 in s1;s2 *)
  | Kseq: statement -&gt; cont -&gt; cont
  (* Kloop1 s1 s2 k = after s1 in Sloop s1 s2 *)
  | Kloop1: statement -&gt; statement -&gt; cont -&gt; cont
  (* Kloop1 s1 s2 k = after s2 in Sloop s1 s2 *)
  | Kloop2: statement -&gt; statement -&gt; cont -&gt; cont
  (* catches break statements arising out of switch *)
  | Kswitch: cont -&gt; cont
  | Kcall: option ident -&gt; (* where to store result *)
           function -&gt; (* calling function *)
           env -&gt; (* local env of calling function *)
           temp_env -&gt; (* temporary env of calling function *)
           cont -&gt; cont.</code></pre>
<p>Note that <code>Kcall</code> continuation constructor contains the definition and environments of calling function to be restored.</p>
</section>
<section id="state" class="slide level1">
<h1>State</h1>
<p>Statements may modify memory state</p>
<pre><code>Inductive state: Type :=
  | State
      (f: function)
      (s: statement)
      (k: cont)
      (e: env)
      (le: temp_env)
      (m: mem) : state
  | Callstate
      (fd: fundef)
      (args: list val)
      (k: cont)
      (m: mem) : state
  | Returnstate
      (res: val)
      (k: cont)
      (m: mem) : state.</code></pre>
</section>
<section id="sequence-statement-evaluation-judgement" class="slide level1">
<h1>Sequence statement evaluation judgement</h1>
<pre><code>Inductive step: state -&gt; trace -&gt; state -&gt; Prop :=

  | step_assign: forall f a1 a2 k e le m loc ofs v2 v m&#39;,
      eval_lvalue e le m a1 loc ofs -&gt;
      eval_expr e le m a2 v2 -&gt;
      sem_cast v2 (typeof a2) (typeof a1) = Some v -&gt;
      assign_loc ge (typeof a1) m loc ofs v m&#39; -&gt;
      step (State f (Sassign a1 a2) k e le m)
        E0 (State f Sskip k e le m&#39;)</code></pre>
</section>
<section id="loop-statement-evaluation-judgements" class="slide level1">
<h1>Loop statement evaluation judgements</h1>
<pre><code>| step_loop: forall f s1 s2 k e le m,
    step (State f (Sloop s1 s2) k e le m)
      E0 (State f s1 (Kloop1 s1 s2 k) e le m)
| step_skip_or_continue_loop1: forall f s1 s2 k e le m x,
    x = Sskip \/ x = Scontinue -&gt;
    step (State f x (Kloop1 s1 s2 k) e le m)
      E0 (State f s2 (Kloop2 s1 s2 k) e le m)
| step_break_loop1: forall f s1 s2 k e le m,
    step (State f Sbreak (Kloop1 s1 s2 k) e le m)
      E0 (State f Sskip k e le m)
| step_skip_loop2: forall f s1 s2 k e le m,
    step (State f Sskip (Kloop2 s1 s2 k) e le m)
      E0 (State f (Sloop s1 s2) k e le m)
| step_break_loop2: forall f s1 s2 k e le m,
    step (State f Sbreak (Kloop2 s1 s2 k) e le m)
      E0 (State f Sskip k e le m)</code></pre>
</section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,         // Display controls in the bottom right corner
        progress: true,         // Display a presentation progress bar
        history: true,          // Push each slide change to the browser history
        fragments: true,
        center: false,                       // Vertical centering of slides
        maxScale: 1.5,                  // Bounds for smallest/largest possible content scale
        slideNumber: "c / t",                // Display the page number of the current slide
        theme: 'maxxk', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
        math: {
          mathjax: 'reveal.js/../MathJax-2.5.3/MathJax.js',
          config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        },

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/math/math.js', async: true },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
