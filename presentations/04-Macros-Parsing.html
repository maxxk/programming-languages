<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="notation-and-proof-assistants">Notation and proof assistants</h2>
<h2 id="formal-syntax-analysis">Formal syntax analysis</h2>
<h2 id="macros-as-a-part-of-syntax">Macros as a part of syntax</h2>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: small !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
</style>
<p>Course page: <a href="https://maxxk.github.io/programming-languages/" class="uri">https://maxxk.github.io/programming-languages/</a><br>
Contact author: <a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#programming-language-specification"></a></div>
<section id="programming-language-specification" class="slide level1">
<h1>Programming language specification</h1>
<p><img src="graphviz-images/aa5f4656547c5b2a7ce97a49486be6e2a63b8520.svg"></p>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#bnf-formally"></a></div>
<section id="bnf-formally" class="slide level1">
<h1>BNF formally</h1>
<p>BNF has a graph structure (actually, a directed hypergraph with per-edge ordered destination nodes). Parse tree is a tree derived from the graph (when you encounter a cycle, vertex is duplicated).</p>
<p><img src="graphviz-images/bf9e1f309d9b94e9d24da483ef8f703eb63e3c0a.svg"></p>
<div class="smallish">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">term ::= factor | term <span class="ch">'+'</span> factor
factor ::= atom | factor <span class="ch">'*'</span> atom
atom ::= number | <span class="ch">'('</span> term <span class="ch">')'</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">(<span class="dv">3</span>+<span class="dv">2</span>)*<span class="dv">4</span>+<span class="dv">1</span></code></pre></div>
</div>
</section><div><a class="slider-prev" href="#programming-language-specification"></a><a class="slider-next" href="#mechanization"></a></div>
<section id="mechanization" class="slide level1">
<h1>Mechanization</h1>
<div class="smaller">
Programs are complex. In theory, you can make a mathematical description of a programming language with some assumptions. You can't usually prove properties on paper. Therefore we have to use some (mathematically correct) mechanization tools to make a precise reasoning about the program. In the present course we employ Agda and Coq as the mechanization tools.
</div>
<div class="twocolumn" style="font-size: 0.5em;">
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> HashEntry
{
<span class="kw">private</span>:

      <span class="dt">int</span> key;
      <span class="dt">int</span> value;

<span class="kw">public</span>:

      HashEntry(<span class="dt">int</span> key, <span class="dt">int</span> value)
      {
            <span class="kw">this</span>-&gt;key = key;
            <span class="kw">this</span>-&gt;value = value;
      }

      <span class="dt">int</span> getKey() { <span class="cf">return</span> key; }

      <span class="dt">int</span> getValue() { <span class="cf">return</span> value; }
};

<span class="at">const</span> <span class="dt">int</span> TABLE_SIZE = <span class="dv">128</span>;

<span class="kw">class</span> HashMap
{
<span class="kw">private</span>:

      HashEntry **table;

<span class="kw">public</span>:

      HashMap()
      {
            table = <span class="kw">new</span> HashEntry*[TABLE_SIZE];

            <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; TABLE_SIZE; i++)
                  table[i] = NULL;
      }

      <span class="dt">int</span> get(<span class="dt">int</span> key)
      {
            <span class="dt">int</span> hash = (key % TABLE_SIZE);

            <span class="cf">while</span> (table[hash] != NULL &amp;&amp; table[hash]-&gt;getKey() != key)
                  hash = (hash + <span class="dv">1</span>) % TABLE_SIZE;

            <span class="cf">if</span> (table[hash] == NULL)
                  <span class="cf">return</span> <span class="dv">-1</span>;
            <span class="cf">else</span>
                  <span class="cf">return</span> table[hash]-&gt;getValue();
      }

      <span class="dt">void</span> put(<span class="dt">int</span> key, <span class="dt">int</span> value)
      {
            <span class="dt">int</span> hash = (key % TABLE_SIZE);

            <span class="cf">while</span> (table[hash] != NULL &amp;&amp; table[hash]-&gt;getKey() != key)
                  hash = (hash + <span class="dv">1</span>) % TABLE_SIZE;

            <span class="cf">if</span> (table[hash] != NULL)
                  <span class="kw">delete</span> table[hash];

            table[hash] = <span class="kw">new</span> HashEntry(key, value);
      }     

      ~HashMap()
      {
            <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; TABLE_SIZE; i++)
                  <span class="cf">if</span> (table[i] != NULL)
                        <span class="kw">delete</span> table[i];

            <span class="kw">delete</span>[] table;
      }
};</code></pre></div>
2009 nodes in an abstract syntax tree.<br>
<img src="images/S6kW9.jpg">
</div>
<div class="small">
Example from: <a href="http://stackoverflow.com/a/11025084" class="uri">http://stackoverflow.com/a/11025084</a>
</div>
</section><div><a class="slider-prev" href="#bnf-formally"></a><a class="slider-next" href="#notation"></a></div>
<section id="notation" class="slide level1">
<h1>Notation</h1>
<dl>
<dt class="fragment">A → B</dt>
<dd class="fragment">function from type A to type B
</dd>
<dt class="fragment">(a : A) → B(a)</dt>
<dd class="fragment">dependent function (dependent product) mapping an element <em>a</em> of type A to representative B(a) of<br>
family B : A → Type
</dd>
<dt class="fragment">A + B</dt>
<dd class="fragment">sum type (either an element of A or element of B)<br>
inl : A → A + B<br>
inr : B → A + B
</dd>
<dt class="fragment">A × B</dt>
<dd class="fragment">product type (ordered pair of elements from A and B)<br>
(a, b) : A × B
</dd>
<dt class="fragment">(a : A) × B(a)</dt>
<dd class="fragment">dependent sum, an ordered pair of element <em>a</em> from A and element from representative B(a) of<br>
family B : A → Type
</dd>
</dl>
</section><div><a class="slider-prev" href="#mechanization"></a><a class="slider-next" href="#inductive-types"></a></div>
<section id="inductive-types" class="slide level1">
<h1>Inductive types</h1>
<pre><code>term ::= factor | term '+' factor
factor ::= atom | factor '*' atom
atom ::= number | '(' term ')'</code></pre>
<p>Abstract syntax tree for the grammar is defined by three mutually inductive types:</p>
<pre><code>Term   = TFactor (f : Factor) | TSum (t : Term) (f : Factor)
Factor = FAtom (a : Atom)     | FProduct (f : Factor) (a : Atom)
Atom   = ANumber (n : Number) | AGroup (t : Term)</code></pre>
</section><div><a class="slider-prev" href="#notation"></a><a class="slider-next" href="#pattern-matching"></a></div>
<section id="pattern-matching" class="slide level1">
<h1>Pattern matching</h1>
<p>An interpreter for an abstract syntax tree from previous slide is defined with pattern matching (case analysis) on inductive type constructors:<br>
interpretTerm : Term → Number<br>
interpretTerm (TFactor f) = interpretFactor f<br>
interpretTerm (TSum t f) = (interpretTerm t) + (interpretFactor f)<br>
interpretFactor : Factor → Number<br>
interpretFactor (FAtom a) = interpretAtom a<br>
interpretFactor (FProduct f a) = (interpretFactor f) * (interpretAtom a)<br>
interpretAtom : Atom → Number<br>
interpretAtom (ANumber n) = n<br>
interpretAtom (AGroup t) = interpretTerm t</p>
</section><div><a class="slider-prev" href="#inductive-types"></a><a class="slider-next" href="#proof-assistants-coq-and-agda"></a></div>
<section id="proof-assistants-coq-and-agda" class="slide level1">
<h1>Proof assistants: Coq and Agda</h1>
<p>Coq and Agda are the proof assistants based on dependently-typed lambda calculus (<a href="https://maxxk.github.io/formal-models/">remember the previous semester</a>).</p>
<h2 id="coq">Coq</h2>
<p>ML-like syntax.<br>
Homepage: <a href="https://coq.inria.fr" class="uri">https://coq.inria.fr</a><br>
Textbook: <a href="http://adam.chlipala.net/cpdt/" class="uri">http://adam.chlipala.net/cpdt/</a><br>
Quickstart (in Russian): <a href="https://habrahabr.ru/post/182442/" class="uri">https://habrahabr.ru/post/182442/</a><br>
Another short texbook (in Russian): <a href="http://lpcs.math.msu.su/~krupski/download/coq_pract.pdf" class="uri">http://lpcs.math.msu.su/~krupski/download/coq_pract.pdf</a></p>
<h2 id="agda">Agda</h2>
<p>Haskell-like syntax.<br>
Homepage: <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.HomePage" class="uri">http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.HomePage</a><br>
Introduction paper: <a href="http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf" class="uri">http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf</a><br>
Example (in Russian): <a href="https://habrahabr.ru/post/148769/" class="uri">https://habrahabr.ru/post/148769/</a></p>
</section><div><a class="slider-prev" href="#pattern-matching"></a><a class="slider-next" href="#coq-and-agda"></a></div>
<section id="coq-and-agda" class="slide level1">
<h1>Coq and Agda</h1>
<p>In Coq and Agda all definable functions are (under the normal circumstances) total, which means:</p>
<ol type="1">
<li class="fragment">The function will accept any input of the specified type, errors like Haskell's "non-exhaustive patterns" are not possible:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">helper ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [(<span class="dt">Integer</span>,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
helper n [] (v) _ <span class="fu">=</span> []
helper n (x<span class="fu">:</span>y<span class="fu">:</span>xs) (v) (c<span class="fu">:</span>cs) <span class="fu">=</span>
    <span class="kw">if</span> (chinese3 (b<span class="fu">:</span>c<span class="fu">:</span>cs) <span class="fu">==</span> n)
      <span class="kw">then</span> (x<span class="fu">:</span>v)
    <span class="kw">else</span> helper n (xs) (x<span class="fu">:</span>v) ((n <span class="ot">`mod`</span> y,y)<span class="fu">:</span>c<span class="fu">:</span>cs)
    <span class="kw">where</span> b <span class="fu">=</span>(n <span class="ot">`mod`</span> x,x)

<span class="co">-- helper 10 primes [] [] ⟶ error: Non-exhaustive patterns in function helper.</span></code></pre></div>
<ol start="2" type="1">
<li class="fragment"><p>The function will terminate for any input, infinite recursion is not allowed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">helper a b c d <span class="fu">=</span> helper a (a<span class="fu">:</span>b) c d</code></pre></div></li>
</ol>
</section><div><a class="slider-prev" href="#proof-assistants-coq-and-agda"></a><a class="slider-next" href="#agda-examples"></a></div>
<section id="agda-examples" class="slide level1">
<h1>Agda examples</h1>
<p>Inductive datatype is defined by a set of constructors. Note that indentation is significant (like in Python and Haskell)</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Nat <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    zero <span class="ot">:</span> Nat
    succ <span class="ot">:</span> Nat <span class="ot">→</span> Nat</code></pre></div>
<p>Function on inductive types are defined by the means of pattern matching.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">plus <span class="ot">:</span> Nat <span class="ot">→</span> Nat <span class="ot">→</span> Nat
plus zero m <span class="ot">=</span> m
plus <span class="ot">(</span>succ n<span class="ot">)</span> m <span class="ot">=</span> succ <span class="ot">(</span>plus n m<span class="ot">)</span></code></pre></div>
</section><div><a class="slider-prev" href="#coq-and-agda"></a><a class="slider-next" href="#agda-examples-1"></a></div>
<section id="agda-examples-1" class="slide level1">
<h1>Agda examples</h1>
<p>Dependent product indexed type familiy. Note that the implicit argument n to <code>cons</code> is enclosed in braces.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Vec <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Nat <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
    [] <span class="ot">:</span> Vec A zero
    cons <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Vec A n <span class="ot">→</span> Vec A <span class="ot">(</span>succ n<span class="ot">)</span>

cons zero [] <span class="co">-- Vector with a single element (0)</span>

head <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">→</span> Vec A <span class="ot">(</span>succ n<span class="ot">)</span> <span class="ot">→</span> A
head <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> x</code></pre></div>
</section><div><a class="slider-prev" href="#agda-examples"></a><a class="slider-next" href="#coq-examples"></a></div>
<section id="coq-examples" class="slide level1">
<h1>Coq examples</h1>
<p>Inductive data types. Indentation is not significant in Coq. Statements are terminated by dot <code>.</code></p>
<pre class="coq"><code>Inductive nat : Type :=
 | O : nat
 | S : nat → nat.</code></pre>
<p>There are some different keywords for definitions (<code>Definition</code>, <code>Inductive</code>, <code>Fixpoint</code>, <code>Program Definition</code>). Functions are defined like in lambda-calculus, pattern matching is possible with <code>match</code> expression:</p>
<pre class="coq"><code>Fixpoint plus (a b : nat) : nat :=
  match a with
  | O ⇒ b
  | S a' ⇒ S (plus a' b)
  end.</code></pre>
</section><div><a class="slider-prev" href="#agda-examples-1"></a><a class="slider-next" href="#coq-examples-1"></a></div>
<section id="coq-examples-1" class="slide level1">
<h1>Coq examples</h1>
<p>Dependent type family. As in Agda, implicit arguments are written inside braces, explicit dependent arguments are written insied the round brackets.</p>
<pre class="coq"><code>Inductive Vector (A : Set) : nat → Set :=
  | Nil : Vector A O
  | Cons : forall {n : Nat}, A → Vector A n → Vector a (S n).</code></pre>
<pre class="coq"><code>Definition head' A n (vec : Vector A n) :=
  match vec in (Vector A n) return
    (match n with O ⇒ unit | S _ ⇒ A end) with
    | Nil ⇒ tt
    | Cons h _ ⇒ h
  end.

Definition head A n (vec : Vector A (S n)) : A := head' vec.</code></pre>
</section><div><a class="slider-prev" href="#coq-examples"></a><a class="slider-next" href="#formal-syntax-analysis-1"></a></div>
<section id="formal-syntax-analysis-1" class="slide level1">
<h1>Formal syntax analysis</h1>
<p>Parser is a function which implements syntax analysis.<br>
Suppose we have defined a syntax as a grammar G and an abstract syntax tree and implemented a parser P.</p>
<p>P : String → AST + SyntaxError</p>
<p>How can we make sure that our parser will:</p>
<ol type="1">
<li class="fragment">accept all strings from G-defined language.</li>
<li class="fragment">not accept any string outside of G-defined language.</li>
<li class="fragment">will terminate for every finite input.</li>
</ol>
</section><div><a class="slider-prev" href="#coq-examples-1"></a><a class="slider-next" href="#couldnt-we-just-write-a-parser-in-a-proof-assistant"></a></div>
<section id="couldnt-we-just-write-a-parser-in-a-proof-assistant" class="slide level1">
<h1>Couldn't we just write a parser in a proof assistant?</h1>
<p>From the previous class: left recursion.</p>
<pre><code>term ::= factor | term '+' factor
factor ::= atom | factor '*' atom
atom ::= number | '(' term ')'</code></pre>
<pre><code>x+1 ⟶ ⟂</code></pre>
<p>(try to parse a <code>term</code>, <code>x</code> is not a <code>factor</code> so it must be a <code>term</code> and now we have a cycle)</p>
</section><div><a class="slider-prev" href="#formal-syntax-analysis-1"></a><a class="slider-next" href="#danielsson.-total-parser-combinators-2010"></a></div>
<section id="danielsson.-total-parser-combinators-2010" class="slide level1">
<h1>Danielsson. Total Parser Combinators (2010)</h1>
<p>Main idea is: use the lazy computation. Total, dependently-typed programming languages may represent infinite lazy computations as a corecursive type. After the parsing process is represented as tree with some infinite-depth paths, make a breadth-first search of successful parse result.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> List <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  [] <span class="ot">:</span> List A
  <span class="ot">_</span>::<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> List A <span class="ot">→</span> List A

<span class="kw">data</span> Colist <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  [] <span class="ot">:</span> Colist A
  <span class="ot">_</span>::<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> ∞ <span class="ot">(</span>Colist A<span class="ot">)</span> <span class="ot">→</span> Colist A

♯ <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span>  A <span class="ot">→</span> ∞ A
♭ <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> ∞ A→ A</code></pre></div>
<p><span class="smaller"><br>
Danielsson N.A. Total parser combinators // Proceedings of the 15th ACM SIGPLAN international conference on Functional programming - ICFP ’10. ACM Press, 2010. P. 285–285.<br>
Source and paper is available at: <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators.html" class="uri">http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators.html</a><br>
</span></p>
</section><div><a class="slider-prev" href="#couldnt-we-just-write-a-parser-in-a-proof-assistant"></a><a class="slider-next" href="#danielsson.-total-parser-combinators-2010-1"></a></div>
<section id="danielsson.-total-parser-combinators-2010-1" class="slide level1">
<h1>Danielsson. Total Parser Combinators (2010)</h1>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">map <span class="ot">:</span> <span class="ot">∀{</span>A B<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span> A <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">→</span> Colist A <span class="ot">→</span> Colist B
map f [ ] <span class="ot">=</span> [ ]
map f <span class="ot">(</span>x::xs<span class="ot">)</span> <span class="ot">=</span> f x :: ♯ map f <span class="ot">(</span>♭xs<span class="ot">)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">mutual</span>
  <span class="co">-- The index is true if the corresponding language contains the</span>
  <span class="co">-- empty string (is nullable).</span>
  <span class="kw">data</span> P <span class="ot">:</span> Bool <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
    fail  <span class="ot">:</span> P false
    empty <span class="ot">:</span> P true
    tok   <span class="ot">:</span> Tok <span class="ot">→</span> P false
    <span class="ot">_</span>∣<span class="ot">_</span>   <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n₁ n₂<span class="ot">}</span> <span class="ot">→</span> P n₁ <span class="ot">→</span>            P n₂ <span class="ot">→</span> P <span class="ot">(</span>n₁ ∨ n₂<span class="ot">)</span>
    <span class="ot">_</span>·<span class="ot">_</span>   <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n₁ n₂<span class="ot">}</span> <span class="ot">→</span> P n₁ <span class="ot">→</span> ∞⟨ not n₁ ⟩P n₂ <span class="ot">→</span> P <span class="ot">(</span>n₁ ∧ n₂<span class="ot">)</span>

  <span class="co">-- Coinductive if the index is true.</span>
  ∞⟨<span class="ot">_</span>⟩P <span class="ot">:</span> Bool <span class="ot">→</span> Bool <span class="ot">→</span> <span class="dt">Set</span>
  ∞⟨ true  ⟩P n <span class="ot">=</span> ∞ <span class="ot">(</span>P n<span class="ot">)</span>
  ∞⟨ false ⟩P n <span class="ot">=</span>    P n</code></pre></div>
</section><div><a class="slider-prev" href="#danielsson.-total-parser-combinators-2010"></a><a class="slider-next" href="#danielsson.-total-parser-combinators-2010-2"></a></div>
<section id="danielsson.-total-parser-combinators-2010-2" class="slide level1">
<h1>Danielsson. Total Parser Combinators (2010)</h1>
<p>Example from: <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators/TotalParserCombinators.Examples.Expression.html#233" class="uri">http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators/TotalParserCombinators.Examples.Expression.html#233</a></p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> Monadic <span class="kw">where</span>
  <span class="kw">mutual</span>
    term   <span class="ot">=</span> factor
           ∣ ♯ term            &gt;&gt;= <span class="ot">λ</span> e₁ <span class="ot">→</span>
             tok <span class="ch">'+'</span>           &gt;&gt;= <span class="ot">λ</span> <span class="ot">_</span>  <span class="ot">→</span>
             factor            &gt;&gt;= <span class="ot">λ</span> e₂ <span class="ot">→</span>
             return <span class="ot">(</span>e₁ + e₂<span class="ot">)</span>
    factor <span class="ot">=</span> atom
           ∣ ♯ factor          &gt;&gt;= <span class="ot">λ</span> e₁ <span class="ot">→</span>
             tok <span class="ch">'*'</span>           &gt;&gt;= <span class="ot">λ</span> <span class="ot">_</span>  <span class="ot">→</span>
             atom              &gt;&gt;= <span class="ot">λ</span> e₂ <span class="ot">→</span>
             return <span class="ot">(</span>e₁ * e₂<span class="ot">)</span>
    atom   <span class="ot">=</span> number
           ∣ tok <span class="ch">'('</span>           &gt;&gt;= <span class="ot">λ</span> <span class="ot">_</span>  <span class="ot">→</span>
             ♯ term            &gt;&gt;= <span class="ot">λ</span> e  <span class="ot">→</span>
             tok <span class="ch">')'</span>           &gt;&gt;= <span class="ot">λ</span> <span class="ot">_</span>  <span class="ot">→</span>
             return e</code></pre></div>
</section><div><a class="slider-prev" href="#danielsson.-total-parser-combinators-2010-1"></a><a class="slider-next" href="#and-what-about-proofs"></a></div>
<section id="and-what-about-proofs" class="slide level1">
<h1>And what about proofs?</h1>
<p>Simplification</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="co">-- f &lt;$&gt; fail                  → fail</span>
<span class="co">-- f &lt;$&gt; return x              → return (f x)</span>
<span class="co">-- fail         ∣ p            → p</span>
<span class="co">-- p            ∣ fail         → p</span>
<span class="co">-- token &gt;&gt;= p₁ ∣ token &gt;&gt;= p₂ → token &gt;&gt;= (λ t → p₁ t ∣ p₂ t)  (*)</span>
<span class="co">-- ...</span>
simplify₁ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>Tok R xs<span class="ot">}</span> <span class="ot">(</span>p <span class="ot">:</span> Parser Tok R xs<span class="ot">)</span> <span class="ot">→</span>
            ∃₂ <span class="ot">λ</span> xs <span class="ot">(</span>p′ <span class="ot">:</span> Parser Tok R xs<span class="ot">)</span> <span class="ot">→</span> p ≅P p′</code></pre></div>
<p>Completeness</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="co">-- A proof showing that all functions of type List Bool → List R can</span>
<span class="co">-- be realised using parser combinators (for any R, assuming that bag</span>
<span class="co">-- equality is used for the lists of results).</span>
parser⇒fun <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>R xs<span class="ot">}</span> <span class="ot">(</span>p <span class="ot">:</span> Parser Bool R xs<span class="ot">)</span> <span class="ot">{</span>x s<span class="ot">}</span> <span class="ot">→</span>
             x ∈ p · s ⇿ x ∈ parse p s
maximally-expressive <span class="ot">:</span>
 <span class="ot">∀</span> <span class="ot">{</span>R<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> List Bool <span class="ot">→</span> List R<span class="ot">)</span> <span class="ot">{</span>s<span class="ot">}</span> <span class="ot">→</span>
 parse <span class="ot">(</span>grammar f<span class="ot">)</span> s ≈[ bag ] f s</code></pre></div>
</section><div><a class="slider-prev" href="#danielsson.-total-parser-combinators-2010-2"></a><a class="slider-next" href="#koprowski-binsztok.-trx-a-formally-verified-parser-interpreter"></a></div>
<section id="koprowski-binsztok.-trx-a-formally-verified-parser-interpreter" class="slide level1">
<h1>Koprowski, Binsztok. TRX: A Formally Verified Parser Interpreter</h1>
<p>Main idea: like in original PEG parsers, disallow direct and indirect left-recursive grammars. <a href="http://www.google.com/patents/EP2454661A1?cl=en">Patented</a> algorithm :)</p>
<pre class="coq"><code>Definition wf_analyse (exp : pexp) (wf : PES.t) : bool :=
  match exp with
  | empty ⇒ true
  | range     ⇒ true
  | terminal a ⇒ true
  | anyChar ⇒ true
  | nonTerminal p ⇒ is_wf (production p) wf
  | seq e1 e2 ⇒ is_wf e1 wf ∧ (if e1 − [gp] → 0 then is_wf e2 wf else true) | choice e1 e2 ⇒ is_wf e1 wf ∧ is_wf e2 wf
  | star e ⇒ is_wf e wf ∧ (negb (e − [gp] → 0))
  |note ⇒is_wf e wf
  | id e ⇒ is_wf e wf
end.</code></pre>
<p><span class="smaller"><br>
Koprowski A., Binsztok H. TRX: A Formally Verified Parser Interpreter // Logical Methods in Computer Science / ed. Gordon A. 2011. Vol. 7, № 2.<br>
Note: some approaches exist to enable left-recursive PEG parsing, I must have references somewhere :)<br>
Medeiros S., Ierusalimschy R. A parsing machine for PEGs // Proceedings of the 2008 symposium on Dynamic languages - DLS ’08. 2008. P. 1–12.<br>
</span></p>
</section><div><a class="slider-prev" href="#and-what-about-proofs"></a><a class="slider-next" href="#trx-a-formally-verified-parser-interpreter"></a></div>
<section id="trx-a-formally-verified-parser-interpreter" class="slide level1">
<h1>TRX: A Formally Verified Parser Interpreter</h1>
<pre class="coq"><code>Program Fixpoint parse (T : Type) (e : PExp T | is grammar exp e) (s : string)
{measure (e , s ) ≻ } : {r : ParsingResult T | ∃ n , [ e , s ] ⇒ [ n , r ] }</code></pre>
</section><div><a class="slider-prev" href="#koprowski-binsztok.-trx-a-formally-verified-parser-interpreter"></a><a class="slider-next" href="#see-also"></a></div>
<section id="see-also" class="slide level1">
<h1>See also</h1>
<ol type="1">
<li class="fragment">Uustalu, Tarmo, Firsov, Denis. Certified Parsing of Regular Languages // Certified Programs and Proofs. Springer International Publishing, 2013. P. 98–113.</li>
<li class="fragment">Jourdan J.-H., Leroy X., Pottier F. Validating LR(1) Parsers // Proceedings of the 21st European Symposium on Programming. 2012. Vol. 7211. P. 397–416.</li>
<li class="fragment">Bernardy, Jean-Philippe, Jansson, Patrik. Certified Context-Free Parsing: a Formalisation of Valiant's Algorithm in Agda: Preprint. Chalmers University of Technology, University of Gothenburg, Sweden, 2016. 27 p.</li>
<li class="fragment">Sjöblom, Thomas Bååth. An Agda proof of the correctness of Valiant’s algorithm for context free parsing: MSc. Göteborg University: Chalmers University of Technilogy, University of Gothenburg, 2013. 63 p.</li>
</ol>
</section><div><a class="slider-prev" href="#trx-a-formally-verified-parser-interpreter"></a><a class="slider-next" href="#macros"></a></div>
<section id="macros" class="slide level1">
<h1>Macros</h1>
<p>Macro (macroinstruction) — is a rule of generation a set of instructions in compile-time.</p>
<p>Different kinds of macros may be related to both syntax and static semantics of programming language.</p>
</section><div><a class="slider-prev" href="#see-also"></a><a class="slider-next" href="#macroassemblers-revisited"></a></div>
<section id="macroassemblers-revisited" class="slide level1">
<h1>Macroassemblers revisited</h1>
Macros are substituted before the assembly time.<br>

<div class="twocolumn">
<pre class="x86asm"><code>ForLp           macro   LCV, Start, Stop
ifndef  $$For&amp;LCV&amp;      
$$For&amp;LCV&amp;      =       0
else
$$For&amp;LCV&amp;      =       $$For&amp;LCV&amp; + 1
endif

mov     ax, Start
mov     LCV, ax

MakeLbl $$For&amp;LCV&amp;, %$$For&amp;LCV&amp;

mov     ax, LCV
cmp     ax, Stop
jgDone  $$Next&amp;LCV&amp;, %$$For&amp;LCV&amp;
endm

Next            macro   LCV
inc     LCV
jmpLoop $$For&amp;LCV&amp;, %$$For&amp;LCV&amp;
MakeLbl $$Next&amp;LCV&amp;, %$$For&amp;LCV&amp;
endm</code></pre>
<pre class="x86asm"><code>ForLp   I, 0, 15
ForLp   J, 0, 6

ldax    A, I, J         ;Fetch A[I][J]
mov     bx, 15          ;Compute 16-I.
sub     bx, I
ldax    b, bx, J, imul  ;Multiply in B[15-I][J].
stax    x, J, I         ;Store to X[J][I]

Next    J
Next    I</code></pre>
</div>
</section><div><a class="slider-prev" href="#macros"></a><a class="slider-next" href="#preprocessors"></a></div>
<section id="preprocessors" class="slide level1">
<h1>Preprocessors</h1>
<p>Preprocessor is a program which operates on input data for some other program. Preprocessors may be used to provide primitive macro facilities.</p>
<p>Preprocessor : String → String</p>
</section><div><a class="slider-prev" href="#macroassemblers-revisited"></a><a class="slider-next" href="#c-preprocessor"></a></div>
<section id="c-preprocessor" class="slide level1">
<h1>C preprocessor</h1>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span>

<span class="pp">#ifndef _WINDOW_H</span>
<span class="pp">#define _WINDOW_H</span>
<span class="pp">#endif</span>

<span class="pp">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span>

<span class="pp">#if VERBOSE &gt;= 2</span>
  print(<span class="st">"trace message"</span>);
<span class="pp">#endif</span>

<span class="pp">#if !(defined __LP64__ || defined __LLP64__) || defined _WIN32 &amp;&amp; !defined _WIN64</span>
<span class="pp">#error 32-bit systems not supported</span>
<span class="pp">#else</span>
    <span class="co">// we are compiling for a 64-bit system</span>
<span class="pp">#endif</span></code></pre></div>
</section><div><a class="slider-prev" href="#preprocessors"></a><a class="slider-next" href="#c-preprocessor-1"></a></div>
<section id="c-preprocessor-1" class="slide level1">
<h1>C preprocessor</h1>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define xstr(s) str(s)</span>
<span class="pp">#define str(s) #s</span>
<span class="pp">#define foo 4</span>

str (foo)  <span class="co">// outputs "foo"</span>
xstr (foo) <span class="co">// outputs "4"</span>

<span class="pp">#define DECLARE_STRUCT_TYPE(name) typedef struct name##_s name##_t</span>

DECLARE_STRUCT_TYPE(g_object);
<span class="co">// Outputs: typedef struct g_object_s g_object_t;</span></code></pre></div>
<p>(It is even possible to write limited recursive programs in C preprocessor by itself: <a href="https://github.com/pfultz2/Cloak/wiki/Is-the-C-preprocessor-Turing-complete%3F">https://github.com/pfultz2/Cloak/wiki/Is-the-C-preprocessor-Turing-complete%3F</a>)</p>
</section><div><a class="slider-prev" href="#c-preprocessor"></a><a class="slider-next" href="#m4-t4"></a></div>
<section id="m4-t4" class="slide level1">
<h1>M4 / T4</h1>
<p>Some external preprocessors feature complex programming languages for template transformations:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> Decorator: &lt;#= <span class="kw">interface</span>.<span class="fu">FullName</span> #&gt;
{    <span class="co">// …</span>
&lt;#
    <span class="kw">foreach</span>(Member member <span class="kw">in</span> interfaceType.<span class="fu">Members</span>)
        <span class="fu">WriteMember</span>(member);
#&gt;
}</code></pre></div>
</section><div><a class="slider-prev" href="#c-preprocessor-1"></a><a class="slider-next" href="#lisp-reader-macros"></a></div>
<section id="lisp-reader-macros" class="slide level1">
<h1>LISP Reader Macros</h1>
<p>In LISP there are different kinds of macros: ordinary macros which transfrom abstract syntax tree and reader macros which transform a string to an abstract syntax tree.</p>
<p>ReaderMacro : String × (genericReader : String → AST) → AST</p>
<p>In LISP reader macros are implemented by means of modifying <em>read table:</em> a mapping from characters to further actions.<br>
ReadTable : Char → (String → AST)<br>
Reader : (readtable : ReadTable) → (nexttable : Char → ReadTable) → String → AST</p>
<p>See an example at: <a href="https://gist.github.com/chaitanyagupta/9324402" class="uri">https://gist.github.com/chaitanyagupta/9324402</a></p>
</section><div><a class="slider-prev" href="#m4-t4"></a><a class="slider-next" href="#tex"></a></div>
<section id="tex" class="slide level1">
<h1>TeX</h1>
<p>TeX is actually built around reader macros:<br>
<a href="https://en.wikibooks.org/wiki/TeX/catcode" class="uri">https://en.wikibooks.org/wiki/TeX/catcode</a></p>
<pre><code>0 = Escape character, normally \
1 = Begin grouping, normally {
2 = End grouping, normally }
3 = Math shift, normally $
4 = Alignment tab, normally &amp;
5 = End of line, normally &lt;return&gt;
6 = Parameter, normally #
7 = Superscript, normally ^
8 = Subscript, normally _
9 = Ignored character, normally &lt;null&gt;
10 = Space, normally &lt;space&gt; and &lt;tab&gt;
11 = Letter, normally only contains the letters a,...,z and A,...,Z. These characters can be used in command names
12 = Other, normally everything else not listed in the other categories
13 = Active character, for example ~
14 = Comment character, normally %
15 = Invalid character, normally &lt;delete&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode latex"><code class="sourceCode latex"><span class="co">% \makeatletter substitute:</span>
<span class="fu">\hello@</span> <span class="co">% is two tokens \hello  @ by default</span>

<span class="co">% make @ an ordinary letter</span>
<span class="fu">\catcode</span>`<span class="fu">\@</span>=11<span class="fu">\relax</span> 

<span class="fu">\hello@</span> <span class="co">% is a single token \hello@</span></code></pre></div>
</section><div><a class="slider-prev" href="#lisp-reader-macros"></a><a class="slider-next" href="#lisp-macros"></a></div>
<section id="lisp-macros" class="slide level1">
<h1>LISP Macros</h1>
<p>Macro : AST → AST</p>
<p>Macros transform program AST at some stage before the evaluation.</p>
<p>Example: short-circuit evaluation</p>
<p>C:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">A() 
  &amp;&amp; B() <span class="co">// only run if A returned non-zero</span>
  &amp;&amp; C(); <span class="co">// only run if both A and B returned non-zero</span>

and(A(), B(), C()) <span class="co">// will evaluate A(), B() and C() before going inside and </span></code></pre></div>
<p>LISP:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">defmacro</span><span class="fu"> </span>&amp;&amp; (expr1 &amp;rest exprs)
    `(<span class="kw">if</span> ,expr1
         (&amp;&amp; ,@exprs)
         nil))

(&amp;&amp; (A) (B) (C))</code></pre></div>
</section><div><a class="slider-prev" href="#tex"></a><a class="slider-next" href="#lisp-macros-1"></a></div>
<section id="lisp-macros-1" class="slide level1">
<h1>LISP Macros</h1>
<p>Complex example: SQL-like queries in LISP:<br>
<a href="https://marijnhaverbeke.nl/postmodern/s-sql.html" class="uri">https://marijnhaverbeke.nl/postmodern/s-sql.html</a></p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(:select (:+ 'field-<span class="dv">1</span> <span class="dv">100</span>) 'field-<span class="dv">5</span>
   :from (:as 'my-table 'x)
   :left-join 'your-table :on (:= 'x.field-<span class="dv">2</span> 'your-table.field-<span class="dv">1</span>)
   :where (:not-null 'a.field-<span class="dv">3</span>))</code></pre></div>
</section><div><a class="slider-prev" href="#lisp-macros"></a><a class="slider-next" href="#lisp-macros-2"></a></div>
<section id="lisp-macros-2" class="slide level1">
<h1>LISP Macros</h1>
<p>The evaluation of macro invocation is split in two stages: expansion-time (first stage, in compiler) and run-time (second stage, in program).</p>
<p>Macro code starts running in expansion-time.<br>
The run-time is separated from expansion-time with <em>quotation</em> operators:</p>
<ul>
<li class="fragment"><code>'</code> — quote</li>
<li class="fragment"><code>`</code> — quasiquote, allowing for unquoting with operator <code>,</code></li>
</ul>
<p>Examples:</p>
<ul>
<li class="fragment"><code>(f a b c)</code> – call function <code>f</code> with arguments <code>a</code>, <code>b</code>, <code>c</code> and replace macro invocation node in AST with the result</li>
<li class="fragment"><code>'(f a b c)</code> – return list (AST) with symbols <code>f</code>, <code>a</code>, <code>b</code>, <code>c</code> as its elements</li>
<li class="fragment"><code>`(f a b ,(+ 1 2))</code> – evaluate <code>(+ 1 2)</code> at expansion time and return list <code>(f a b 3)</code></li>
</ul>
<p>What the code from the previous example does?</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">`(<span class="kw">if</span> ,expr1
         (&amp;&amp; ,@exprs)
         nil))</code></pre></div>
</section><div><a class="slider-prev" href="#lisp-macros-1"></a><a class="slider-next" href="#macros-in-rust"></a></div>
<section id="macros-in-rust" class="slide level1">
<h1>Macros in Rust</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> vec <span class="op">{</span>
    ( $( $x:expr ),* ) =&gt; <span class="op">{</span>
        <span class="op">{</span>
            <span class="kw">let</span> <span class="kw">mut</span> temp_vec = <span class="dt">Vec</span>::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        <span class="op">}</span>
    <span class="op">}</span>;
<span class="op">}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Vec</span>&lt;<span class="dt">u32</span>&gt; = <span class="pp">vec!</span><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">]</span>; 
<span class="co">// expanded:</span>
<span class="kw">let</span> x : <span class="dt">Vec</span>&lt;<span class="dt">u32</span>&gt; = <span class="op">{</span>
  <span class="kw">let</span> <span class="kw">mut</span> temp_vec_1234 = <span class="dt">Vec</span>::new();
  temp_vec.push(<span class="dv">1</span>);
  temp_vec.push(<span class="dv">2</span>);
  temp_vec.push(<span class="dv">3</span>);
  temp_vec
<span class="op">}</span></code></pre></div>
</section><div><a class="slider-prev" href="#lisp-macros-2"></a><a class="slider-next" href="#homework-assignments"></a></div>
<section id="homework-assignments" class="slide level1">
<h1>Homework assignments</h1>
<p><strong>Task 4.1</strong> (6*) Implement Danielsson's Total Parser Combinators in Coq.</p>
<p><strong>Task 4.2a</strong>* Write (manually) an extensible parser for LISP-like symbolic expressions (subset of <a href="http://www.scheme-reports.org">"R7RS small"</a> Scheme specification). Whitespace, identifier and number specifications are omitted as a trivial exercise.</p>
<pre><code>&lt;datum&gt; ::= &lt;atom&gt; &lt;optional whitespace&gt; | &lt;list&gt; &lt;optional whitespace&gt;
&lt;atom&gt; ::= &lt;identifier&gt; | &lt;number&gt; | &lt;string&gt;
&lt;string&gt; ::= '"' &lt;string element&gt;* '"'
&lt;string element&gt; ::= &lt;any character except " and \&gt; | '\"' | '\\'
&lt;list&gt; ::= "(" &lt;datum&gt;  ")"</code></pre>
</section><div><a class="slider-prev" href="#macros-in-rust"></a><a class="slider-next" href="#homework-assignments-1"></a></div>
<section id="homework-assignments-1" class="slide level1">
<h1>Homework assignments</h1>
<p><strong>Task 4.2b</strong>** Implement reader macros for a subset of a context-free grammar as an interpreter from s-expressions to parser extension. It'll be easier to implement in some lanugage featuring <code>eval</code> command (like JavaScript, Python or LISP family)</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(reader-macro &lt;start-string&gt; &lt;stop-string&gt; &lt;grammar&gt;)
<span class="co">; Example:</span>
(reader-macro <span class="st">"#"</span> <span class="st">"#"</span> (float decimal-digits
    (optional <span class="st">"."</span> (optional decimal-digits))
    (optional <span class="st">"e"</span> (either <span class="st">"+"</span> <span class="st">"-"</span> <span class="st">""</span>) decimal-digits)))

#<span class="fl">1.5e11</span># ⟶ (float <span class="st">"1"</span> (<span class="st">"."</span> (<span class="st">"5"</span>)) (<span class="st">"e"</span> (<span class="st">""</span>) <span class="st">"11"</span>))</code></pre></div>
<p><strong>Task 4.2c</strong>* Write a reader macro for infix arithmetical expressions (addition, multiplication, brackets).</p>
</section><div><a class="slider-prev" href="#homework-assignments"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>
