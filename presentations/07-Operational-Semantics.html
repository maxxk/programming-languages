<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>07-Operational-Semantics</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
  <div style="width: 640px;height: 400px;" id="container">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator" id="main">
   <a id="slider-default"></a>
   <label title="Flat view" id="flat-view"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="dynamic-semantics">Dynamic semantics</h2>
<h2 id="operational-sematics">Operational sematics</h2>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: small !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
.inference table {
    display: inline-block;
    padding: 1em;
}

.inference table th {
    font-weight: normal;
    border-bottom: 2px solid black;
}
.ib {
    display: inline-block;
}

</style>
<p><a href="https://maxxk.github.io/programming-languages/" class="uri">https://maxxk.github.io/programming-languages/</a></p>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#programming-language-specification"></a></div>
<section id="programming-language-specification" class="slide level1">
<h1>Programming language specification</h1>
<p><img data-src="graphviz-images/bbe727775038043af9c9c955731db5637b7b6712.svg" src="graphviz-images/bbe727775038043af9c9c955731db5637b7b6712.svg"></p>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#dynamic-semantics-1"></a></div>
<section id="dynamic-semantics-1" class="slide level1">
<h1>Dynamic semantics</h1>
<p>— the semantics of the programming language statements at the run time.</p>
<h2 id="approaches">Approaches</h2>
<h3 id="operational-semantics">Operational Semantics</h3>
<p>The meaning of the program is specified as a sequence of computational steps for some abstract machine.</p>
<h3 id="axiomatic-semantics">Axiomatic Semantics</h3>
<p>The meaning of the program is defined in terms of effects on the program statements on assertions about the program state.</p>
<h3 id="denotational-semantics">Denotational Semantics</h3>
<p>The meaning of the program is formalized as a mathematical object (denotation).</p>
</section><div><a class="slider-prev" href="#programming-language-specification"></a><a class="slider-next" href="#operational-semantics-1"></a></div>
<section id="operational-semantics-1" class="slide level1">
<h1>Operational semantics</h1>
<p>Program execution may be understood as a step-by-step process that evolves by mechanical application of a fixed set of rules.</p>
<p>Rules describe how language constructs affect the state of some <em>abstract machine</em> that provides the mathematical model of computation. Each state of the abstract machine is called <em>configuration</em>.</p>
<div class="smaller">
F. Turbak, D. Gifford. Design Concepts in Programming Languages. Chapter 3. Operational Semantics.
</div>
</section><div><a class="slider-prev" href="#dynamic-semantics-1"></a><a class="slider-next" href="#operational-execution-model"></a></div>
<section id="operational-execution-model" class="slide level1">
<h1>Operational execution model</h1>
<p><img data-src="graphviz-images/429fa226b1a0a9d035e722469c0d820109989672.svg" src="graphviz-images/429fa226b1a0a9d035e722469c0d820109989672.svg"></p>
</section><div><a class="slider-prev" href="#operational-semantics-1"></a><a class="slider-next" href="#big-step-and-small-step-operational-semantics"></a></div>
<section id="big-step-and-small-step-operational-semantics" class="slide level1">
<h1>Big-step and small-step operational semantics</h1>
<p>Small-step operational semantics (Structural Operational Semantics, SOS): step-by-step transformation of configurations in abstract machine is defined by set of rewrite rules.</p>
<div class="smaller">
Gordon D. Plotkin. A Structural Approach to Operational Semantics. (1981) Tech. Rep.&nbsp;DAIMI FN-19, Computer Science Department, Aarhus University, Aarhus, Denmark. (Reprinted with corrections in J. Log. Algebr. Program. 60-61: 17-139 (2004)
</div>
<p>Big-step operational semantics (natural semantics): program execution is described in terms of recursive evaluation of subphrases of a program. Each nontrivial syntactic domain (subset of abstract syntax tree constructors) has its specific evaluation relation.</p>
</section><div><a class="slider-prev" href="#operational-execution-model"></a><a class="slider-next" href="#structural-operational-semantics"></a></div>
<section id="structural-operational-semantics" class="slide level1">
<h1>Structural operational semantics</h1>
<h2 id="set-theoretic-abstract-machine-model">Set-theoretic abstract machine model</h2>
<p>Consider programming language L with well-formed, well-typed programs P ∈ Prog, inputs I ∈ Inputs and answers A ∈ AnsExp.</p>
<p>Structural operational semantics for L is five-tuple S = 〈 CF, ⇒, FC, IF, OF 〉</p>
<ul>
<li class="fragment">cf ∈ CF — <strong>domain of configurations</strong> for an abstract machine</li>
<li class="fragment">⇒ — <strong>transition relation</strong>, “⇒” ⊆ CF × CF. Two configurations are in transition relation iff there is a <strong>(one step) transition</strong> from cf to cf’</li>
</ul>
<p>cf ⇒ cf’ ⇔ 〈 cf, cf’ 〉 ∈ ⇒</p>
<p><span class="math inline">⇒<sup>*</sup></span> — reflexive transitive closure of ⇒. Sequence of transitions cf <span class="math inline">⇒<sup>*</sup></span> cf’ is called <strong>transition path</strong>.</p>
<p>Configuration cf is <strong>reducible</strong> if there is some cf’ such that cf ⇒ cf’, otherwise cf is <strong>irreducible</strong>.</p>
<p>Transition relation <span class="math inline">⇒</span> is <strong>deterministic</strong> if for every cf there is exactly one cf’, otherwise ⇒ is <strong>nondeterministic</strong>.</p>
</section><div><a class="slider-prev" href="#big-step-and-small-step-operational-semantics"></a><a class="slider-next" href="#structural-operational-semantics-1"></a></div>
<section id="structural-operational-semantics-1" class="slide level1">
<h1>Structural operational semantics</h1>
<p>Structural operational semantics for language L is five-tuple S = 〈 CF, ⇒, FC, IF, OF 〉</p>
<ul>
<li class="fragment"><p>Irreducible — all irreducible configurations</p></li>
<li class="fragment"><p>FC — set of <strong>final configurations</strong> which yield the correct answer, FC ⊂ Irreducible</p></li>
<li class="fragment"><p>Stuck = Irreducible / FC — set of stuck states, nonfinal irreducible configurations (e.g.&nbsp;error states)</p></li>
<li class="fragment"><p>IF : (Prog × Inputs) → CF — <strong>input function</strong>, transforms a program and its inputs to an initial configuration</p></li>
<li class="fragment"><p>OF : FC → AnsExp — <strong>output function</strong>, maps a program and its inputs to an initial configuration</p></li>
</ul>
</section><div><a class="slider-prev" href="#structural-operational-semantics"></a><a class="slider-next" href="#program-behavior"></a></div>
<section id="program-behavior" class="slide level1">
<h1>Program behavior</h1>
<p>Outcome = AnsExp + ErrorResult (+ — disjoint union)</p>
<p>Deterministic behavior, if <span class="math inline">⇒</span> is deterministic:</p>
<p><span class="math inline"><em>b</em><em>e</em><em>h</em><sub><em>d</em><em>e</em><em>t</em></sub></span> : (Prog × Inputs) → Outcome</p>
<p><span class="math inline"><em>b</em><em>e</em><em>h</em><sub><em>d</em><em>e</em><em>t</em></sub></span> 〈 P, I 〉 | IF 〈 P, I 〉 <span class="math inline">⇒<sup>*</sup></span> cf ∈ FC = AnsExp ↦ Outcome (OF cf)</p>
<p><span class="math inline"><em>b</em><em>e</em><em>h</em><sub><em>d</em><em>e</em><em>t</em></sub></span> 〈 P, I 〉 | IF 〈 P, I 〉 <span class="math inline">⇒<sup>*</sup></span> cf ∈ Stuck = ErrorResult</p>
<p><span class="math inline"><em>b</em><em>e</em><em>h</em><sub><em>d</em><em>e</em><em>t</em></sub></span> 〈 P, I 〉 | IF 〈 P, I 〉 <span class="math inline">⇒<sup>∞</sup></span> = ∞</p>
</section><div><a class="slider-prev" href="#structural-operational-semantics-1"></a><a class="slider-next" href="#non-deterministic-behavior"></a></div>
<section id="non-deterministic-behavior" class="slide level1">
<h1>Non-deterministic behavior</h1>
<p>𝒫 (A) — powerset of <span class="math inline"><em>A</em></span> (set of all subsets of A).</p>
<p>beh : (Prog × Inputs) → 𝒫 (Outcome)</p>
<p>o ∈ beh( 〈P, I〉 ) <strong>if</strong> o = AnsExp ↦ Outcome (OF cf) <strong>and</strong> IF 〈P, I〉 <span class="math inline">⇒<sup>*</sup></span> cf ∈ FC</p>
<p>o ∈ beh( 〈P, I〉 ) <strong>if</strong> o ∈ ErrorResult <strong>and</strong> IF 〈 P, I 〉 <span class="math inline">⇒<sup>*</sup></span> cf ∈ Stuck</p>
<p>o ∈ beh( 〈P, I〉 ) <strong>if</strong> o = ∞ <strong>and</strong> IF 〈P, I〉 <span class="math inline">⇒<sup>∞</sup></span></p>
</section><div><a class="slider-prev" href="#program-behavior"></a><a class="slider-next" href="#rewrite-rules"></a></div>
<section id="rewrite-rules" class="slide level1 inference">
<h1 class="inference">Rewrite rules</h1>
<p>Usually relations on complex domains are specified in terms of <strong>formal inference system.</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">antecendents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">consequents</td>
</tr>
</tbody>
</table>
<p><span class="math inline"><em>a</em><em>n</em><em>t</em><em>e</em><em>c</em><em>e</em><em>d</em><em>e</em><em>n</em><em>t</em><em>s</em> = ⊘</span> ⇒ rule is called <strong>axiom</strong>, otherwise <strong>progress rule</strong>.</p>
<p>Example axioms for stack-based language (placing constant on stack; configuration state = 〈 command sequence, stack 〉):</p>
<p>〈 N . Q, S〉 ⇒ 〈 Q, N . S 〉 [num]</p>
<p>〈 (Q) . R, S〉 ⇒ 〈 R, (Q) . S 〉 [seq]</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">S = S1 . S2 . Sn</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">〈 swap . Q, S〉 ⇒ 〈 Q, S2 . S1 . Sn 〉</td>
</tr>
</tbody>
</table>
<p>If cf is a configuration in which first command in sequence is constant, then there is a transition from cf to cf’ in which constant is moved from command sequence to the top of the stack.</p>
</section><div><a class="slider-prev" href="#non-deterministic-behavior"></a><a class="slider-next" href="#example-structural-operational-semantics-execution"></a></div>
<section id="example-structural-operational-semantics-execution" class="slide level1">
<h1>Example structural operational semantics execution</h1>
<p><img data-src="images/postfix-sos.png" src="images/postfix-sos.png"></p>
</section><div><a class="slider-prev" href="#rewrite-rules"></a><a class="slider-next" href="#subexpression-evaluation"></a></div>
<section id="subexpression-evaluation" class="slide level1">
<h1>Subexpression evaluation</h1>
<p><img data-src="images/elmm-transition.png" src="images/elmm-transition.png"></p>
</section><div><a class="slider-prev" href="#example-structural-operational-semantics-execution"></a><a class="slider-next" href="#evaluation-contexts"></a></div>
<section id="evaluation-contexts" class="slide level1">
<h1>Evaluation contexts</h1>
<p><img data-src="images/evaluation-contexts.png" src="images/evaluation-contexts.png"></p>
</section><div><a class="slider-prev" href="#subexpression-evaluation"></a><a class="slider-next" href="#big-step-operational-semantics"></a></div>
<section id="big-step-operational-semantics" class="slide level1">
<h1>Big-step operational semantics</h1>
<p>Big-step operational semantics (natural semantics): program execution is described in terms of recursive evaluation of subphrases of a program. Each nontrivial syntactic domain (subset of abstract syntax tree constructors) has its specific evaluation relation.</p>
<p>E.g. <span class="math inline">→<sub><em>N</em><em>E</em></sub></span> for numerical expressions and <span class="math inline">→<sub><em>P</em><em>r</em><em>o</em><em>g</em></sub></span> for programs.</p>
</section><div><a class="slider-prev" href="#evaluation-contexts"></a><a class="slider-next" href="#big-step-operational-semantics-1"></a></div>
<section id="big-step-operational-semantics-1" class="slide level1">
<h1>Big-step operational semantics</h1>
<p><img data-src="images/big-step-elm.png" src="images/big-step-elm.png"></p>
</section><div><a class="slider-prev" href="#big-step-operational-semantics"></a><a class="slider-next" href="#language-properties"></a></div>
<section id="language-properties" class="slide level1">
<h1>Language properties</h1>
<p>Usually operational semantics is used to prove some of the following properties:</p>
<ul>
<li class="fragment">universality: the language can express all computable programs;</li>
<li class="fragment">determinism: the set of possible outcomes from executing a program on any particular inputs is a singleton;</li>
<li class="fragment">strong normalization: all programs are guaranteed to terminate on all inputs (i.e., it is not possible to express an infinite loop);</li>
<li class="fragment">static checkability: a class of program errors can be found by static analysis without resorting to execution;</li>
<li class="fragment">referential transparency: different occurrences of an expression within the same context always have the same meaning.</li>
</ul>
</section><div><a class="slider-prev" href="#big-step-operational-semantics-1"></a><a class="slider-next" href="#example-proof-of-termination"></a></div>
<section id="example-proof-of-termination" class="slide level1">
<h1>Example proof of termination</h1>
<p>Turbak, Gifford. p.&nbsp;85</p>
</section><div><a class="slider-prev" href="#language-properties"></a><a class="slider-next" href="#k-framework"></a></div>
<section id="k-framework" class="slide level1">
<h1>K Framework</h1>
<p><a href="http://www.kframework.org/" class="uri">http://www.kframework.org/</a></p>
</section><div><a class="slider-prev" href="#example-proof-of-termination"></a><a class="slider-next" href="#homework-assignments"></a></div>
<section id="homework-assignments" class="slide level1">
<h1>Homework Assignments</h1>
<p>Turbak, Gifford. Exercises 3.3, 3.4, 3.5, 3.6, 3.10a, 3.10b, 3.18, 3.19, 3.22, 3.24, 3.25 (one star each, at most 3 stars)</p>
</section><div><a class="slider-prev" href="#k-framework"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  function handleKeydown(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 33: // Page Up
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 34: // Page Down
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  }
  document.addEventListener("keydown", handleKeydown);
  document.getElementById("flat-view").addEventListener("click", function(e) {
    document.getElementById("main").classList.toggle('slider');
    if (document.getElementById("main").classList.contains('slider')) {
      document.getElementById("container").style="width: 640px;height: 400px;";
      document.addEventListener("keydown", handleKeydown);
    } else {
      document.getElementById("container").style="";
      document.removeEventListener("keydown", handleKeydown);
    }
  })
  </script>
  

</body></html>
