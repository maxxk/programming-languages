<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>03-Specification-Syntax</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;" id="container">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator" id="main">
   <a id="slider-default"></a>
   <label title="Flat view" id="flat-view"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="programming-language-specification">Programming Language Specification</h2>
<h2 id="formal-syntax">Formal syntax</h2>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: smaller ; }
</style>
<p><a href="https://maxxk.github.io/programming-languages/" class="uri">https://maxxk.github.io/programming-languages/</a></p>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#additions"></a></div>
<section id="additions" class="slide level1">
<h1>Additions</h1>
<h2 id="optional-typing-systems">Optional typing systems</h2>
<p>In similar way to the annotations of model checking tools, the optional type checkers do not neccessarily accept all correct programs.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*::</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">type BinaryTree =</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">  { kind: "leaf", value: number } |</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">  { kind: "branch", left: BinaryTree, right: BinaryTree }</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sumLeaves</span>(tree <span class="co">/*: BinaryTree*/</span>)<span class="op">:</span> number {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>tree<span class="op">.</span><span class="at">left</span>) { <span class="co">// condition was: kind == "leaf"</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tree<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">sumLeaves</span>(tree<span class="op">.</span><span class="at">left</span>) <span class="op">+</span> <span class="fu">sumLeaves</span>(tree<span class="op">.</span><span class="at">right</span>)<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#addition"></a></div>
<section id="addition" class="slide level1">
<h1>Addition</h1>
<h2 id="remember-computer-science-is-old">Remember: Computer Science is old</h2>
<ul>
<li class="fragment">First programming languages and compilers apperared in 1950s.</li>
<li class="fragment">Classical textbooks, e.g.&nbsp;the first edition of ‚ÄúDragon book‚Äù (Aho, Ullman. Principles of Compiler Design) appeared in 1977.</li>
<li class="fragment">Commonly-known technology and mathematics may be outdated.</li>
<li class="fragment">Example: ‚Äústandard‚Äù character set: machine-specific character set ‚Üí ANSI/Locale-specific encoding (C) ‚Üí UCS-2 (C#, JavaScript) ‚Üí UTF-8</li>
</ul>
<pre><code>"üëç".length = 2</code></pre>
</section><div><a class="slider-prev" href="#additions"></a><a class="slider-next" href="#programming-language-specification-1"></a></div>
<section id="programming-language-specification-1" class="slide level1">
<h1>Programming language specification</h1>
<p>Linguistics in general is concerned with three main aspects of a written language:</p>
<ol type="1">
<li class="fragment"><p><strong>Syntax</strong> ‚Äî the way in which linguistic elements (words) are put together to form constituents (phrases).</p></li>
<li class="fragment"><p><strong>Semantics</strong> ‚Äî the meanings of words and phrases in language.</p></li>
<li class="fragment"><p><strong>Pragmatics</strong> ‚Äî the relationship between sentences to the environment in which they occur.</p></li>
</ol>
<p>(non-computer languages also have:</p>
<ul>
<li class="fragment"><p><em>morphology</em> ‚Äî the study of language morphemes, words; the study and description of word formation (as inflection, derivation, and compounding) in language</p></li>
<li class="fragment"><p><em>phonology</em> ‚Äî the study of the speech sounds used in a language</p>
<p>)</p></li>
</ul>
<p>Definitions from <a href="http://www.merriam-webster.com/dictionary/">Merriam-Webster</a></p>
<p>See also: <a href="http://web.archive.org/web/20170922094027/http://www.sbql.pl/Topics/Syntax%20semantics%20and%20pragmatics.html">Archive: http://www.sbql.pl/Topics/Syntax%20semantics%20and%20pragmatics.html</a></p>
</section><div><a class="slider-prev" href="#addition"></a><a class="slider-next" href="#programming-language-specification-2"></a></div>
<section id="programming-language-specification-2" class="slide level1">
<h1>Programming language specification</h1>
<p><img data-src="graphviz-images/d28958ffcf5115f8b7cae26100163f4165a819ff.svg" src="graphviz-images/d28958ffcf5115f8b7cae26100163f4165a819ff.svg"></p>
</section><div><a class="slider-prev" href="#programming-language-specification-1"></a><a class="slider-next" href="#syntax"></a></div>
<section id="syntax" class="slide level1">
<h1>Syntax</h1>
<p>Syntax of a programming language is concerned with the form of programs: how expressions, commands, declarations and other constructs must be arranged to make a well-formed program.</p>
<p><span class="small">Definition from D. Watt ‚Äî Programming Language Design Concepts</span></p>
<p>In other words: How the program is written and how the compiler/interpreter expects it to be formed.</p>
</section><div><a class="slider-prev" href="#programming-language-specification-2"></a><a class="slider-next" href="#syntax-example"></a></div>
<section id="syntax-example" class="slide level1">
<h1>Syntax: example</h1>
<p><a href="https://stackoverflow.com/questions/5508110/why-is-this-program-erroneously-rejected-by-three-c-compilers/" class="uri">https://stackoverflow.com/questions/5508110/why-is-this-program-erroneously-rejected-by-three-c-compilers/</a></p>
</section><div><a class="slider-prev" href="#syntax"></a><a class="slider-next" href="#syntax-example-1"></a></div>
<section id="syntax-example-1" class="slide level1">
<h1>Syntax: example</h1>
<p>Suppose we want to compute the sum of the product of <em>v</em> and <em>w</em> and the quotient of <em>y</em> and <em>z</em>. Syntax representations:</p>
<ul>
<li class="fragment">mathematical expression: v¬∑w +
<div style="display: inline-flex; flex-direction: column; justify-content: center;">
<div style="border-bottom: 2pt solid black;">
y
</div>
<div>
z
</div>
</div></li>
<li class="fragment">traditional infix notation: <code>v*w + y/z</code></li>
<li class="fragment">LISP prefix S-expression: <code>(+ (* v w) (/ y z))</code></li>
<li class="fragment">reverse polish notation / stack calculator: <code>v w * y z / +</code></li>
<li class="fragment">graph-based syntax (not related to previous examples) <a href="https://noflojs.org/dataflow-noflo/demo/draggabilly.html" class="uri">https://noflojs.org/dataflow-noflo/demo/draggabilly.html</a> <a href="https://noflojs.org/example/" class="uri">https://noflojs.org/example/</a></li>
<li class="fragment">some kind of <a href="https://blockly-demo.appspot.com/static/demos/blockfactory/index.html">visual ‚Äúsyntax‚Äù</a> and <a href="http://guilabs.net/">structured editors</a> <img data-src="images/scratch-syntax.png" src="images/scratch-syntax.png"></li>
<li class="fragment">tagged representation <a href="https://github.com/AshleyF/Color/blob/master/Docs/beautiful_simplicity.md">(colorForth)</a></li>
<li class="fragment"><a href="https://www.unisonweb.org/docs/tour">content-addressed ¬´database¬ª representation</a></li>
</ul>
<p>First example is based on F. Turbak, D. Gifford. Design Concepts in Programming Languages</p>
</section><div><a class="slider-prev" href="#syntax-example"></a><a class="slider-next" href="#semantics"></a></div>
<section id="semantics" class="slide level1">
<h1>Semantics</h1>
<p>Semantics of a programming language is concerned with the meaning of programs: how a well-formed program may be expected to behave when executed on a computer.</p>
<p><span class="small">Definition from D. Watt ‚Äî Programming Language Design Concepts</span></p>
<p>We will spend about a half of the course on this topic, but today we discuss just the syntax.</p>
</section><div><a class="slider-prev" href="#syntax-example-1"></a><a class="slider-next" href="#semantics-example"></a></div>
<section id="semantics-example" class="slide level1">
<h1>Semantics: example</h1>
<p>A well-formed formula <code>x*y + z</code> may have meaning:</p>
<ul>
<li>compute the specified formula to get a numerical value as an answer for specific values of <em>x, y, z</em>
<ul>
<li>integral operations for integers</li>
<li>floating-point operations for floating-point number</li>
<li>logical or lattice operations (disjunction and conjunction, max and min)</li>
</ul></li>
<li>(python) replicate <em>y</em> times the string stored in <em>x</em> and concatenate it with <em>z</em> converted to string</li>
<li>just a symbolic expression for the further optimization</li>
<li>etc.</li>
</ul>
</section><div><a class="slider-prev" href="#semantics"></a><a class="slider-next" href="#pragmatics"></a></div>
<section id="pragmatics" class="slide level1">
<h1>Pragmatics</h1>
<p>A programming language‚Äôs pragmatics is concerned with the way in which the language is intended to be used in practice.</p>
<p><span class="small">Definition from D. Watt ‚Äî Programming Language Design Concepts</span></p>
<p>No general consensus on the definition. Two sides:</p>
<ul>
<li>human interface (how the programmers are expected to design and implement programs in practice: design patterns, concurrency support and specific model, foreign function interfaces, packaging system; exception-based control flow :)</li>
<li>implementation details (specific garbage collection algorithm, semantics-preserving optimizations)</li>
</ul>
<div class="fragment">
<p>Note: Evaluation strategy (strict / lazy) is a part of semantics (because the change of strategy changes the meaning of the same syntactic formula).</p>
</div>
</section><div><a class="slider-prev" href="#semantics-example"></a><a class="slider-next" href="#formal-specification"></a></div>
<section id="formal-specification" class="slide level1">
<h1>Formal specification</h1>
<p>Our objective is to get a precise mathematical description of a program.</p>
<p>Each part of language specification must be implemented in mathematical terms.</p>
</section><div><a class="slider-prev" href="#pragmatics"></a><a class="slider-next" href="#syntax-1"></a></div>
<section id="syntax-1" class="slide level1">
<h1>Syntax</h1>
<h2 id="listchar-abstractsyntaxtree">List&lt;Char&gt; ‚ü∂ AbstractSyntaxTree</h2>
</section><div><a class="slider-prev" href="#formal-specification"></a><a class="slider-next" href="#syntax-relation-to-formal-languages"></a></div>
<section id="syntax-relation-to-formal-languages" class="slide level1">
<h1>Syntax: relation to formal languages</h1>
<p>(regular ‚äÇ context-free ‚äÇ context-sensitive ‚äÇ unbounded)</p>
<p>We could make a relation between programs and formal languages in many ways:</p>
<ul>
<li class="fragment"><p>language <span class="math inline"><em>L</em><sub><em>w</em><em>f</em></sub></span>, containing all well-formed (syntactically correct) programs</p></li>
<li class="fragment"><p>language <span class="math inline"><em>L</em><sub><em>w</em><em>t</em></sub>‚ÄÑ‚äÜ‚ÄÑ<em>L</em><sub><em>w</em><em>f</em></sub></span>, containing all well-typed (runnable) programs</p>
<p><span class="math inline"><em>L</em><sub><em>w</em><em>f</em></sub>‚ÄÖ‚àñ‚ÄÖ<em>L</em><sub><em>w</em><em>t</em></sub></span> ‚Äî ‚Äúsyntax gap‚Äù, well-formed programs which are not well-typed</p></li>
<li class="fragment"><p>language <span class="math inline"><em>L</em><sub><em>c</em></sub>‚ÄÑ‚äÜ‚ÄÑ<em>L</em><sub><em>w</em><em>t</em></sub></span>, containing all semantically-correct programs (running without errors)</p>
<p><span class="math inline"><em>L</em><sub><em>w</em><em>t</em></sub>‚ÄÖ‚àñ‚ÄÖ<em>L</em><sub><em>c</em></sub></span> ‚Äî ‚Äútyping gap‚Äù, well-typed programs which throw errors in run-time</p></li>
</ul>
<p>It is obvious that for almost every practical (‚ÄúTuring complete‚Äù) programming language <span class="math inline"><em>L</em><sub><em>c</em></sub></span> is unbounded. For the modern languages, <span class="math inline"><em>L</em><sub><em>w</em><em>f</em></sub></span> is usually context-free or some subset of context-free languages (Deterministic Context-Free Languages, unambiguous languages which can be accepted by deterministic pushdown automaton and therefore can be parsed in <span class="math inline"><em>O</em>(<em>n</em>)</span>).</p>
<p><span class="math inline"><em>L</em><sub><em>w</em><em>t</em></sub></span> may be decidable, but usually decidability is not proven. Compiler freezes may be caused by undecidability of type checking.</p>
</section><div><a class="slider-prev" href="#syntax-1"></a><a class="slider-next" href="#lexical-analysis"></a></div>
<section id="lexical-analysis" class="slide level1">
<h1>Lexical analysis</h1>
<h2 id="listchar-listtoken">List&lt;Char&gt; ‚ü∂ List&lt;Token&gt;</h2>
<p>Traditionally decision problem of <span class="math inline"><em>L</em><sub><em>w</em><em>f</em></sub></span> -membership (well-formedness of a program) is split by two parts:</p>
<ol type="1">
<li class="fragment">lexical analysis transforms a sequence of characters to a sequence of tokens (marked groups of characters, like identifiers, integers, etc.):</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main <span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> argv<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>      main      <span class="op">(</span>    <span class="dt">int</span>       argc    <span class="op">,</span>     <span class="dt">char</span>     argv      <span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>KEYWORD IDENTIFIER LPAR KEYWORD IDENTIFIER COMMA KEYWORD IDENTIFIER RPAR</span></code></pre></div>
<ul>
<li class="fragment">usually lexical specification of the language is regular</li>
<li class="fragment">Unicode standard defines base categories for a lexical analysis (identifier start, identifier, digit, punctuation etc.)</li>
</ul>
</section><div><a class="slider-prev" href="#syntax-relation-to-formal-languages"></a><a class="slider-next" href="#syntax-analysis"></a></div>
<section id="syntax-analysis" class="slide level1">
<h1>Syntax analysis</h1>
<h2 id="listtoken-abstractsyntaxtree">List&lt;Token&gt; ‚ü∂ AbstractSyntaxTree</h2>
<ol start="2" type="1">
<li class="fragment">Syntax analysis transforms a sequence of tokens to a syntax tree.</li>
</ol>
<ul>
<li class="fragment"><strong>concrete syntax</strong>: the syntax of a language including all the features visible in the source code such as parentheses and delimiters;</li>
<li class="fragment"><strong>abstract syntax</strong>: the high-level description of a language structure independent of machine-oriented structures and encodings.</li>
</ul>
<p><img data-src="images/ast-example-js.png" src="images/ast-example-js.png"> <span class="small">Source: <a href="http://azu.github.io/slide/JSojisan/resources/ast-is-true.png" class="uri">http://azu.github.io/slide/JSojisan/resources/ast-is-true.png</a></span></p>
</section><div><a class="slider-prev" href="#lexical-analysis"></a><a class="slider-next" href="#abstract-syntax-tree"></a></div>
<section id="abstract-syntax-tree" class="slide level1">
<h1>Abstract Syntax Tree</h1>
<p>‚Äî a representation of an abstract syntax of a program</p>
<p><img data-src="images/ast-example.png" src="images/ast-example.png"></p>
<p>Multiple representations of <a href="#syntax-example-1">concrete syntax</a> may correspond to a single abstract syntax tree.</p>
<div class="fragment">
<p>Lisp S-expression is a direct representation of abstract syntax tree:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">+</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">*</span> v w)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">/</span> y z) )</span></code></pre></div>
</div>
</section><div><a class="slider-prev" href="#syntax-analysis"></a><a class="slider-next" href="#language-specification"></a></div>
<section id="language-specification" class="slide level1">
<h1>Language specification</h1>
<p>Foraml languages (which are (possibly infinite) subsets of strings of some alphabet: Œ£*) usually have a finite description, which is called ‚Äúgrammar‚Äù.</p>
<ul>
<li class="fragment"><strong>generative grammar:</strong> how to generate all strings of the language starting from a single ‚Äústart‚Äù symbol</li>
<li class="fragment"><strong>analytic grammar:</strong> how to get an abstract syntax tree (a tree of rule applications) from a given string</li>
</ul>
</section><div><a class="slider-prev" href="#abstract-syntax-tree"></a><a class="slider-next" href="#bnf-backus-normal-form"></a></div>
<section id="bnf-backus-normal-form" class="slide level1">
<h1>BNF: Backus Normal Form</h1>
<p>(Backus-Naur Form, by Dijkstra, because ‚Äúit is not a normal form‚Äù)</p>
<p>During the development of ALGOL 60, John Backus proposed a notation for context-free grammars:</p>
<ul>
<li><p>group of characters named <em>expr</em> is denoted as <code>&lt;expr&gt;</code>;</p></li>
<li><p>character constants are quoted: <code>"("</code></p></li>
<li><p>sequence of constants and groups defines a sequence: <code>"(" &lt;expr&gt; ")"</code></p></li>
<li><p>group of characters is defined by an operator <code>::=</code>:</p>
<pre><code>&lt;expr&gt; ::= "(" &lt;atom&gt; ")"</code></pre></li>
<li><p>definitions may use recursion:</p>
<pre><code>&lt;parens&gt; ::= "" | "(" &lt;parens&gt; ")"</code></pre></li>
<li><p>at the right side of the definition operator the alternative operator <strong>|</strong> is allowed:</p>
<pre><code>&lt;expr&gt; ::= &lt;expr&gt; | &lt;expr&gt; &lt;add-operation&gt; &lt;atom&gt;</code></pre></li>
</ul>
<p>BNF is the generative grammar specification language.</p>
</section><div><a class="slider-prev" href="#language-specification"></a><a class="slider-next" href="#bnf-example"></a></div>
<section id="bnf-example" class="slide level1">
<h1>BNF example</h1>
<pre class="bnf"><code>&lt;syntax&gt;         ::= &lt;rule&gt; | &lt;rule&gt; &lt;syntax&gt;
&lt;rule&gt;           ::= &lt;opt-whitespace&gt; "&lt;" &lt;rule-name&gt; "&gt;" &lt;opt-whitespace&gt; "::=" &lt;opt-whitespace&gt; &lt;expression&gt; &lt;line-end&gt;
&lt;opt-whitespace&gt; ::= " " &lt;opt-whitespace&gt; | ""
&lt;expression&gt;     ::= &lt;list&gt; | &lt;list&gt; &lt;opt-whitespace&gt; "|" &lt;opt-whitespace&gt; &lt;expression&gt;
&lt;line-end&gt;       ::= &lt;opt-whitespace&gt; &lt;EOL&gt; | &lt;line-end&gt; &lt;line-end&gt;
&lt;list&gt;           ::= &lt;term&gt; | &lt;term&gt; &lt;opt-whitespace&gt; &lt;list&gt;
&lt;term&gt;           ::= &lt;literal&gt; | "&lt;" &lt;rule-name&gt; "&gt;"
&lt;literal&gt;        ::= '"' &lt;text&gt; '"' | "'" &lt;text&gt; "'"</code></pre>
</section><div><a class="slider-prev" href="#bnf-backus-normal-form"></a><a class="slider-next" href="#bnf-specifications"></a></div>
<section id="bnf-specifications" class="slide level1">
<h1>BNF specifications</h1>
<ul>
<li class="fragment">Extended BNF (EBNF, specification ISO/IEC 14977)</li>
<li class="fragment">Augmented BNF (ABNF, specification IETF <a href="https://tools.ietf.org/html/rfc5234">RFC 5324</a>, <a href="https://tools.ietf.org/html/rfc7405">RFC 7405</a>)</li>
</ul>
</section><div><a class="slider-prev" href="#bnf-example"></a><a class="slider-next" href="#peg-parsing-expression-grammar"></a></div>
<section id="peg-parsing-expression-grammar" class="slide level1">
<h1>PEG: Parsing Expression Grammar</h1>
<p>Analytical grammar formalism, a superset of regular expressions:</p>
<ul>
<li class="fragment">atomic expressions: empty string Œµ, terminal symbol (constant), non-terminal symbol (rule reference)</li>
<li class="fragment">sequence: <span class="math inline"><em>e</em><sub>1</sub>‚ÄÖ<em>e</em><sub>2</sub></span></li>
<li class="fragment"><em>ordered</em> choice: <span class="math inline"><em>e</em><sub>1</sub>‚ÄÖ/‚ÄÖ<em>e</em><sub>2</sub></span></li>
<li class="fragment">Kleene star (zero or more): <span class="math inline"><em>e</em>*</span></li>
<li class="fragment">‚Äúplus‚Äù (one or more): <span class="math inline"><em>e</em>+</span></li>
<li class="fragment">optional: <span class="math inline"><em>e</em>?</span></li>
<li class="fragment">positive lookahead: <span class="math inline">&amp;<em>e</em></span></li>
<li class="fragment">negative lookahead: <span class="math inline">!<em>e</em></span></li>
</ul>
</section><div><a class="slider-prev" href="#bnf-specifications"></a><a class="slider-next" href="#left-recursion"></a></div>
<section id="left-recursion" class="slide level1">
<h1>Left recursion</h1>
<p>Most direct PEG implementations do not support left recursion in grammar. Parsing of the following grammar will not terminate:</p>
<pre><code>Value   ‚Üê [0-9.]+ / '(' Expr ')'
Product ‚Üê Expr (('*' / '/') Expr)*
Sum     ‚Üê Expr (('+' / '-') Expr)*
Expr    ‚Üê Product / Sum / Value</code></pre>
<p>Rewriting grammars to remove left recursion is possible (see ‚ÄúDragon book‚Äù).</p>
</section><div><a class="slider-prev" href="#peg-parsing-expression-grammar"></a><a class="slider-next" href="#infix-operators"></a></div>
<section id="infix-operators" class="slide level1">
<h1>Infix operators</h1>
<p>Infix mathematical notation is probably the only desirable part of syntax which don‚Äôt have nice representations as an S-expression</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(defun triangle (number-of-rows)    <span class="co">; Version with</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">;   incrementing counter.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Add up the number of pebbles in a triangle.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="st">The first row has one pebble, the second row two pebbles,</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="st">the third row three pebbles, and so on.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="st">The argument is NUMBER-OF-ROWS."</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((total <span class="dv">0</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        (row-number <span class="dv">1</span>))</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">while</span> (<span class="op">&lt;=</span> row-number number-of-rows)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      (‚Üê total (<span class="op">+</span> total row-number))</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      (‚Üê row-number (<span class="dv">1</span>+ row-number)))</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    total))</span></code></pre></div>
</section><div><a class="slider-prev" href="#left-recursion"></a><a class="slider-next" href="#precedence-and-associativity"></a></div>
<section id="precedence-and-associativity" class="slide level1">
<h1>Precedence and associativity</h1>
<p>Infix operators are complicated for parsing:</p>
<ul>
<li class="fragment">operator precedence: <code>a * b + c</code>, <code>a + b * c</code></li>
<li class="fragment">associative operators: <code>a + b + c</code></li>
<li class="fragment">left-associative operators: division <code>a / b / c</code> ‚ü∂ <code>(a / b) / c</code></li>
<li class="fragment">right-associative operators: assignment <code>a = b = c</code> ‚ü∂ <code>a = (b = c)</code></li>
<li class="fragment">non-associative operators: <code>a &lt; b &lt; c</code> is invalid in C#</li>
</ul>
<p>The non-associatitvity is hard to represent in syntax, so it is usually a property of semantics.</p>
</section><div><a class="slider-prev" href="#infix-operators"></a><a class="slider-next" href="#tdop-algorithm"></a></div>
<section id="tdop-algorithm" class="slide level1">
<h1>TDOP algorithm</h1>
<p>Top-down operator precedence parser</p>
<p>Operator binding power: <code>1 + 2 * 4</code></p>
<ul>
<li class="fragment">right binding power of ‚Äú+‚Äù is 10</li>
<li class="fragment">left binding power of "*" is 20</li>
</ul>
<div class="smaller">
<p>See also:</p>
<ul>
<li class="fragment">Interactive example <a href="http://l-lang.org/blog/TDOP---Pratt-parser-in-pictures/" class="uri">http://l-lang.org/blog/TDOP---Pratt-parser-in-pictures/</a></li>
<li class="fragment">simple implementation <a href="http://javascript.crockford.com/tdop/tdop.html" class="uri">http://javascript.crockford.com/tdop/tdop.html</a></li>
<li class="fragment">Nitra language workbench (russian project): <a href="https://github.com/rsdn/nitra" class="uri">https://github.com/rsdn/nitra</a></li>
<li class="fragment">original Pratt paper: <a href="https://tdop.github.io" class="uri">https://tdop.github.io</a></li>
</ul>
</div>
</section><div><a class="slider-prev" href="#precedence-and-associativity"></a><a class="slider-next" href="#attribute-grammar"></a></div>
<section id="attribute-grammar" class="slide level1">
<h1>Attribute grammar</h1>
<p>If a rule of the grammar is matched, compute an additional information to attach to an AST node.</p>
<pre><code>Expr1 ‚Üí Expr2 + Term [ Expr1.value = Expr2.value + Term.value ]
Expr ‚Üí Term [ Expr.value = Term.value ]
Term1 ‚Üí Term2 * Factor [ Term1.value = Term2.value * Factor.value ]
Term ‚Üí Factor [ Term.value = Factor.value ]
Factor ‚Üí "(" Expr ")" [ Factor.value =  Expr.value ]
Factor ‚Üí integer [ Factor.value = strToInt(integer.str) ]</code></pre>
<div class="smaller">
<p>Live example of calculator implemented as attribute PEG grammar: <a href="http://pegjs.org/online" class="uri">http://pegjs.org/online</a></p>
</div>
</section><div><a class="slider-prev" href="#tdop-algorithm"></a><a class="slider-next" href="#parser-combinators"></a></div>
<section id="parser-combinators" class="slide level1">
<h1>Parser combinators</h1>
<p>Special technique of parser implementation for functional languages (required support of higher-order functions)</p>
<pre><code>type Parser&lt;U, V&gt; = Iterable&lt;U&gt; ‚Üí V

or&lt;U,V&gt; : (left : Parser&lt;U, V&gt;, right : Parser&lt;U, V&gt;) ‚Üí Parser&lt;U, V&gt;
and&lt;U,V&gt; : (left : Parser&lt;U, V&gt;, right : Parser&lt;U, V&gt;) ‚Üí Parser&lt;U, V&gt;
repeat&lt;U, V&gt; : (p : Parser&lt;U, V&gt;) ‚Üí Parser&lt;U, Array&lt;V&gt;&gt;
str : string ‚Üí Parser&lt;string, string&gt;</code></pre>
</section><div><a class="slider-prev" href="#attribute-grammar"></a><a class="slider-next" href="#parser-combinators-1"></a></div>
<section id="parser-combinators-1" class="slide level1">
<h1>Parser combinators</h1>
<p>Advantage: simple, embedded grammar specification</p>
<p>Disadvantage: hard to reason about</p>
<div class="smaller">
<p>Example implementations:</p>
<ul>
<li class="fragment"><a href="http://jakewheat.github.io/intro_to_parsing/">Parsec</a> (Haskell)</li>
<li class="fragment"><a href="https://github.com/jneen/parsimmon">Parsimmon</a> (JavaScript)</li>
<li class="fragment"><a href="http://www.boost.org/doc/libs/1_60_0/libs/spirit/doc/html/index.html">Boost::Spirit</a> (C++)</li>
</ul>
</div>
</section><div><a class="slider-prev" href="#parser-combinators"></a><a class="slider-next" href="#modern-algorithms-and-implementations"></a></div>
<section id="modern-algorithms-and-implementations" class="slide level1">
<h1>Modern algorithms and implementations</h1>
<p>Contex-free grammar parsers:</p>
<ul>
<li class="fragment">theoretical complexity bound: reduced by Valiant to boolean matrix multiplication, <span class="math inline"><em>O</em>(<em>n</em><sup>2.3728639</sup>)</span> with Coppersmith-Wingorad multiplication; <span class="small">Leslie G. Valiant (1975). ‚ÄúGeneral context-free recognition in less than cubic time‚Äù. Journal of Computer and System Sciences 10 (2): 308‚Äì315. <a href="doi:10.1016/s0022-0000(75)80046-8" class="uri">doi:10.1016/s0022-0000(75)80046-8</a>.</span></li>
<li class="fragment">LL(k), LR(k), LALR(k) (c.f. Aho, Ullman ‚ÄúPrinciples of Complier Design‚Äù and <a href="http://www.antlr.org">ANTLR</a> )</li>
<li class="fragment">Earley parser (used in NLP): <span class="math inline"><em>O</em>(<em>n</em><sup>3</sup>)</span> for general context-free grammar, <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> for unambiguous grammar, linear time for some deterministic context-free languages <span class="small">Aycock, John; Horspool, R. Nigel (2002). Practical Earley Parsing. The Computer Journal 45. pp.&nbsp;620‚Äì630. <a href="doi:10.1093/comjnl/45.6.620" class="uri">doi:10.1093/comjnl/45.6.620</a></span></li>
<li class="fragment">GLR: <span class="math inline"><em>O</em>(<em>n</em><sup>3</sup>)</span> upper bound, complexity is lower for ‚Äúmore deterministic‚Äù grammars, <span class="math inline"><em>O</em>(<em>n</em>)</span> for deterministic grammars</li>
<li class="fragment"><a href="http://www.cs.rhul.ac.uk/research/languages/csle/GLLsketch.html">GLL</a>: recent memoization-based algorithm allowing the parser combinator implementation.</li>
</ul>
<p>Non-context-free:</p>
<ul>
<li class="fragment"><a href="http://www.refal.net/rf5_frm.htm">Refal language</a></li>
</ul>
</section><div><a class="slider-prev" href="#parser-combinators-1"></a><a class="slider-next" href="#non-context-free-syntax"></a></div>
<section id="non-context-free-syntax" class="slide level1">
<h1>Non-context-free syntax</h1>
<ul>
<li class="fragment">C++ (templates are Turing-complete and type-aware)</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">bool</span> V<span class="op">&gt;</span> <span class="kw">struct</span> answer <span class="op">{</span> answer<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(){</span><span class="cf">return</span> V<span class="op">;}};</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">bool</span> no<span class="op">,</span> <span class="dt">bool</span> yes<span class="op">,</span> <span class="dt">int</span> f<span class="op">,</span> <span class="dt">int</span> p<span class="op">&gt;</span> <span class="kw">struct</span> IsPrimeHelper</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">:</span> IsPrimeHelper<span class="op">&lt;</span>p <span class="op">%</span> f <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> f <span class="op">*</span> f <span class="op">&gt;=</span> p<span class="op">,</span> f <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> p<span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">bool</span> yes<span class="op">,</span> <span class="dt">int</span> f<span class="op">,</span> <span class="dt">int</span> p<span class="op">&gt;</span> <span class="kw">struct</span> IsPrimeHelper<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> yes<span class="op">,</span> f<span class="op">,</span> p<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">using</span> type <span class="op">=</span> answer<span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;;</span> <span class="op">};</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> f<span class="op">,</span> <span class="dt">int</span> p<span class="op">&gt;</span> <span class="kw">struct</span> IsPrimeHelper<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> f<span class="op">,</span> p<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">using</span> type <span class="op">=</span> answer<span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;;</span> <span class="op">};</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> I<span class="op">&gt;</span> <span class="kw">using</span> IsPrime <span class="op">=</span> <span class="kw">typename</span> IsPrimeHelper<span class="op">&lt;!(</span>I<span class="op">&amp;</span><span class="dv">1</span><span class="op">),</span> <span class="kw">false</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> I<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> I<span class="op">&gt;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> X <span class="op">{</span> <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> i <span class="op">=</span> I<span class="op">;</span> <span class="dt">int</span> a<span class="op">[</span>i<span class="op">];</span> <span class="op">};</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">&gt;</span> <span class="kw">struct</span> foo<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span><span class="kw">struct</span> foo<span class="op">&lt;</span>answer<span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;&gt;{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> I<span class="op">&gt;</span> <span class="kw">using</span> typen <span class="op">=</span> X<span class="op">&lt;</span>I<span class="op">&gt;;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> foo<span class="op">&lt;</span>answer<span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;&gt;{</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> typen <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> b <span class="op">=</span> foo<span class="op">&lt;</span>IsPrime<span class="op">&lt;</span><span class="dv">234799</span><span class="op">&gt;&gt;::</span>typen<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;();</span> <span class="co">// Syntax error if not prime</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><span class="small"><a href="http://stackoverflow.com/questions/14589346/is-c-context-free-or-context-sensitive" class="uri">http://stackoverflow.com/questions/14589346/is-c-context-free-or-context-sensitive</a></span></p>
</section><div><a class="slider-prev" href="#modern-algorithms-and-implementations"></a><a class="slider-next" href="#home-reading"></a></div>
<section id="home-reading" class="slide level1">
<h1>Home reading</h1>
<p>Kenneth E. Iverson (the creator of APL). Notation as a Tool of Thought. 1979 ACM Turing Award Lecture</p>
<p><a href="http://www.jsoftware.com/papers/tot.htm" class="uri">http://www.jsoftware.com/papers/tot.htm</a></p>
</section><div><a class="slider-prev" href="#non-context-free-syntax"></a><a class="slider-next" href="#homework-assignments"></a></div>
<section id="homework-assignments" class="slide level1">
<h1>Homework assignments</h1>
<p><strong>Task 3.1</strong>** Implement parser combinators in a programming language of your choice which supports higher-order functions. At least the following combinators must be implemented:</p>
<ul>
<li class="fragment">string or regex parser</li>
<li class="fragment">sequence (a, b )</li>
<li class="fragment">Kleene star</li>
<li class="fragment">composition (a ‚àò b: parse a, pass result to b; if b fails, whole composition fails)</li>
<li class="fragment">lookahead (a | b : parse a, try parse b, if b succeeds, continue parsing from the last part of a)</li>
</ul>
<p><strong>Task 3.2</strong>* Define a regular expression for C/C++ floating point numbers. You can use the <a href="https://regex101.com/" class="uri">https://regex101.com/</a></p>
<p><strong>Task 3.3a</strong>* Define a grammar for a non-trivial subset of an existing programming language in BNF, PEG or parser combinators.</p>
<p><strong>Task 3.3b</strong>** Implement a parser for a non-trivial subset of an existing programming language (preferrably in PEG.js, but you can use tool of your choice).</p>
<p><strong>Task 3.3c</strong>***(+**) Implement a parser for S-expressions and prove the correctness property (for any input string the parser either throws an exception or returns an abstract syntax tree which can be serialized to a string equivalent to input in some sense). An implementation in dependently-typed language (Coq, Agda, Idris) is preferred, you will get additional two stars for task 1.1. Parser must support lists, symbols, numbers, strings with escape characters (\n, \t, \").</p>
<!--
# Project

**Project Step 2.**
~ Define an abstract syntax tree for the language in S-expression terms.

**Project Step 2'.**
~ Design a simple concrete syntax specification (in BNF or any other formalism) and implement a parser for the language (from sequence of characters to abstract syntax tree conforming to Step 2 specification)
-->
</section><div><a class="slider-prev" href="#home-reading"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  function handleKeydown(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 33: // Page Up
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 34: // Page Down
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  }
  document.addEventListener("keydown", handleKeydown);
  document.getElementById("flat-view").addEventListener("click", function(e) {
    document.getElementById("main").classList.toggle('slider');
    if (document.getElementById("main").classList.contains('slider')) {
      document.getElementById("container").style="width: 640px;height: 400px;";
      document.addEventListener("keydown", handleKeydown);
    } else {
      document.getElementById("container").style="";
      document.removeEventListener("keydown", handleKeydown);
    }
  })
  </script>
  

</body></html>
