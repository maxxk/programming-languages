<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="additional.css">
  <link rel="stylesheet" href="reveal.js/css/highlight-github.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="software-and-programming-language-theory">Software and Programming Language Theory</h1>
<h2 id="dynamic-semantics">Dynamic semantics</h2>
<h2 id="operational-sematics">Operational sematics</h2>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
.small { font-size: small !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
.reveal section {
  text-align: left;
}
</style>
<p>Course page: <a href="https://maxxk.github.io/programming-languages-2016/" class="uri">https://maxxk.github.io/programming-languages-2016/</a><br />
Contact author: <script type="text/javascript">
<!--
h='&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#x6d;&#x61;&#120;&#x69;&#x6d;&#46;&#x6b;&#114;&#x69;&#118;&#x63;&#104;&#x69;&#x6b;&#x6f;&#118;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x6d;&#x61;&#120;&#x69;&#x6d;&#46;&#x6b;&#114;&#x69;&#118;&#x63;&#104;&#x69;&#x6b;&#x6f;&#118;&#32;&#x61;&#116;&#32;&#x67;&#x6d;&#x61;&#x69;&#108;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;</noscript></p>
<h1 id="programming-language-specification">Programming language specification</h1>
<p><img src="graphviz-images/bbe727775038043af9c9c955731db5637b7b6712.svg" id="alt" /></p>
<h1 id="dynamic-semantics-1">Dynamic semantics</h1>
<p>— the semantics of the programming language statements at the run time.</p>
<h2 id="approaches">Approaches</h2>
<h3 id="operational-semantics">Operational Semantics</h3>
<p>The meaning of the program is specified as a sequence of computational steps for some abstract machine.</p>
<h3 id="axiomatic-semantics">Axiomatic Semantics</h3>
<p>The meaning of the program is defined in terms of effects on the program statements on assertions about the program state.</p>
<h3 id="denotational-semantics">Denotational Semantics</h3>
<p>The meaning of the program is formalized as a mathematical object (denotation).</p>
<h1 id="operational-semantics-1">Operational semantics</h1>
<p>(the most direct for imperative programmer)<br />
Program execution may be understood as a step-by-step process that evolves by mechanical application of a fixed set of rules.<br />
Rules describe how language constructs affect the state of some <em>abstract machine</em> that provides the mathematical model of computation. Each state of the abstract machine is called <em>configuration</em>.</p>
<div class="smaller">
F. Turbak, D. Gifford. Design Concepts in Programming Languages. Chapter 3. Operational Semantics.
</div>
<h1 id="operational-execution-model">Operational execution model</h1>
<p><img src="graphviz-images/429fa226b1a0a9d035e722469c0d820109989672.svg" id="alt" /></p>
<h1 id="big-step-and-small-step-operational-semantics">Big-step and small-step operational semantics</h1>
<p>Small-step operational semantics (Structural Operational Semantics, SOS): step-by-step transformation of configurations in abstract machine is defined by set of rewrite rules.</p>
<div class="smaller">
Gordon D. Plotkin. A Structural Approach to Operational Semantics. (1981) Tech. Rep. DAIMI FN-19, Computer Science Department, Aarhus University, Aarhus, Denmark. (Reprinted with corrections in J. Log. Algebr. Program. 60-61: 17-139 (2004)
</div>
<p>Big-step operational semantics (natural semantics): program execution is described in terms of recursive evaluation of subphrases of a program. Each nontrivial syntactic domain (subset of abstract syntax tree constructors) has some specific evaluation relation.</p>
<h1 id="structural-operational-semantics">Structural operational semantics</h1>
<h2 id="set-theoretic-abstract-machine-model">Set-theoretic abstract machine model</h2>
<p>Consider programming language L with well-formed, well-typed programs P ∈ Prog, inputs I ∈ Inputs and answers A ∈ AnsExp.</p>
<p>Structural operational semantics for L is five-tuple S = 〈 CF, ⇒, FC, IF, OF 〉</p>
<ul>
<li>cf ∈ CF — <strong>domain of configurations</strong> for an abstract machine</li>
<li>⇒ — <strong>transition relation</strong>, &quot;⇒&quot; ⊆ CF × CF. Two configurations are in transition relation iff there is a <strong>(one step) transition</strong> from cf to cf'<br />
cf ⇒ cf' ⇔ 〈 cf, cf' 〉 ∈ ⇒</li>
</ul>
<p><span class="math inline">\(⇒^*\)</span> — reflexive transitive closure of ⇒. Sequence of transitions cf <span class="math inline">\(⇒^*\)</span> cf' is called <strong>transition path</strong>.</p>
<p>Configuration cf is <strong>reducible</strong> if there is some cf' such that cf ⇒ cf', otherwisf cf is <strong>irreducible</strong>.</p>
<p>Transition relation <span class="math inline">\(⇒\)</span> is <strong>deterministic</strong> if for every cf there is exactly one <span class="math inline">\(cf&#39;\)</span>, otherwise ⇒ is <strong>nondeterministic</strong>.</p>
<h1 id="structural-operational-semantics-1">Structural operational semantics</h1>
<p>Structural operational semantics for language L is five-tuple S = 〈 CF, ⇒, FC, IF, OF 〉</p>
<ul>
<li>Irreducible — all irreducible configurations</li>
<li>FC — set of <strong>final configurations</strong> which yield the correct answer, FC ⊂ Irreducible</li>
<li><p>Stuck = Irreducible / FC — set of stuck states, nonfinal irreducible configurations (e.g. error states)</p></li>
<li><p>IF : (Prog × Inputs) → CF — <strong>input function</strong>, transforms a program and its inputs to an initial configuration</p></li>
<li><p>OF : FC → AnsExp — <strong>output function</strong>, maps a program and its inputs to an initial configuration</p></li>
</ul>
<h1 id="program-behavior">Program behavior</h1>
<p>Outcome = AnsExp + ErrorResult (+ — disjoint union)</p>
<p>Deterministic behavior, if <span class="math inline">\(⇒\)</span> is deterministic:<br />
<span class="math display">\[
beh_{det} : (\mathrm{Prog} × \mathrm{Inputs}) → \mathrm{Outcome}
\]</span><br />
<span class="math display">\[
beh_{det} 〈 P, I 〉 = \left\{ \begin{array}{lcl}
AnsExp ↦ Outcome (OF cf) &amp; \text{if } &amp; IF 〈P, I〉 ⇒^* cf ∈ FC, \\
ErrorResult &amp; \text{if } &amp; IF 〈P, I〉 ⇒^* cf ∈ Stuck, \\
∞ &amp; \text{if } &amp; IF 〈P, I〉 ⇒^∞.
\end{array} \right.
\]</span></p>
<h1 id="non-deterministic-behavior">Non-deterministic behavior</h1>
<p><span class="math inline">\(\mathcal{P}(A)\)</span> — powerset of <span class="math inline">\(A\)</span>.</p>
<p><span class="math display">\[
beh : (\mathrm{Prog} × \mathrm{Inputs}) → \mathcal{P}(\mathrm{Outcome})
\]</span></p>
<p><span class="math display">\[
o ∈ beh( 〈P, I〉 ) \; \mathrm{if} \; \left\{ \begin{array}{lcl}
o = AnsExp ↦ Outcome (OF cf) &amp; \text{and} &amp; (IF 〈P, I〉 ⇒^* cf ∈ FC \\
o ∈ ErrorResult &amp; \text{and} &amp; IF 〈 P, I 〉 ⇒^* cf ∈ Stuck \\
o = ∞ &amp; \text{and} &amp; IF 〈P, I〉 ⇒^∞
\end{array}\right.
\]</span></p>
<h1 id="rewrite-rules">Rewrite rules</h1>
<p>Usually relations on complex domains are specified in terms of <strong>formal inference system.</strong></p>
<p><span class="math display">\[
\dfrac{antecedents}{consequences} [name]
\]</span></p>
<p><span class="math inline">\(antecedents = ⊘\)</span> ⇒ rule is called <strong>axiom</strong>, otherwise <strong>progress rule</strong>.</p>
<p>Example axiom for stack-based language (placing constant on stack; configuration state = 〈 command sequence, stack 〉):</p>
<p>〈 N . Q, S〉 ⇒ 〈 Q, N . S 〉 [num]</p>
<p>If cf is a configuration in which first command in sequence is constant, then there is a transition from cf to cf' in which constant is moved from command sequence to the top of the stack.</p>
<h1 id="example-structural-operational-semantics-execution">Example structural operational semantics execution</h1>
<p><img src="images/postfix-sos.png" /></p>
<h1 id="subexpression-evaluation">Subexpression evaluation</h1>
<p><img src="images/elmm-transition.png" /></p>
<h1 id="evaluation-contexts">Evaluation contexts</h1>
<p><img src="images/evaluation-contexts.png" /></p>
<h1 id="big-step-operational-semantics">Big-step operational semantics</h1>
<p>Big-step operational semantics (natural semantics): program execution is described in terms of recursive evaluation of subphrases of a program. Each nontrivial syntactic domain (subset of abstract syntax tree constructors) has some specific evaluation relation.</p>
<p>E.g. $ →_{NE}$ for numerical expressions and <span class="math inline">\(→_{Prog}\)</span> for programs.</p>
<h1 id="big-step-operational-semantics-1">Big-step operational semantics</h1>
<p><img src="images/big-step-elm.png" /></p>
<h1 id="language-properties">Language properties</h1>
<p>Usually operational semantics is used to prove some of the following properties:</p>
<ul>
<li>universality: the language can express all computable programs;</li>
<li>determinism: the set of possible outcomes from executing a program on any<br />
particular inputs is a singleton;</li>
<li>strong normalization: all programs are guaranteed to terminate on all inputs<br />
(i.e., it is not possible to express an infinite loop);</li>
<li>static checkability: a class of program errors can be found by static analysis<br />
without resorting to execution;</li>
<li>referential transparency: different occurrences of an expression within the<br />
same context always have the same meaning.</li>
</ul>
<h1 id="example-proof-of-termination">Example proof of termination</h1>
<p>Turbak, Gifford. p. 85</p>
</body>
</html>
