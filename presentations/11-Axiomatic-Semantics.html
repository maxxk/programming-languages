<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>11-Axiomatic-Semantics</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;" id="container">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator" id="main">
   <a id="slider-default"></a>
   <label title="Flat view" id="flat-view"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="axiomatic-semantics">Axiomatic Semantics</h2>
<p><a href="https://maxxk.github.io/programming-languages/">https://maxxk.github.io/programming-languages/</a></p>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#axiomatic-semantics-literature"></a></div>
<section id="axiomatic-semantics-literature" class="slide level1">
<h1>Axiomatic semantics literature</h1>
<ol type="1">
<li class="fragment"><em>Chapter 6 of</em> <strong>Winskel G. The Formal Semantics of Programming Languages. Cambridge, Massachusetts, US: MIT Press, 1993. xx+361 p.</strong></li>
<li class="fragment"><em>Part IV of</em> Шилов Н.В. Основы синтаксиса, семантики, трансляции и верификации программ: учебное пособие. Новосибирск: НГУ, 2011. 292 p.</li>
<li class="fragment">Статьи по предикатному программированию (В.И. Шелехов)</li>
</ol>
<h2 id="bibliography">Bibliography</h2>
<ol start="3" type="1">
<li class="fragment">Floyd R.W. Assigning Meanings to Programs // Mathematical Aspects of Computer Science / ed. Schwartz J.T. American Mathematical Society, 1967. Vol. 19. P. 19–32.</li>
<li class="fragment">Hoare C.A.R. An axiomatic basis for computer programming // Communications of the ACM. 1969. Vol. 12, № 10. P. 576–580.</li>
<li class="fragment">Dijkstra E.W. Guarded commands, nondeterminacy and formal derivation of programs // Communications of the ACM. 1975. Vol. 18, № 8. P. 453–457.</li>
</ol>
<h2 id="further-reading">Further reading</h2>
<ol start="6" type="1">
<li class="fragment">Ynot (<a href="http://ynot.cs.harvard.edu">http://ynot.cs.harvard.edu</a>) — Imperative programming with Hoare logic in Coq.</li>
<li class="fragment">Chen H. et al. Using Crash Hoare logic for certifying the FSCQ file system. ACM Press, 2015. P. 18–37.</li>
<li class="fragment"><a href="http://web.eecs.umich.edu/~weimerw/590/lectures/weimer-gradpl-08.pdf">Lecture 1</a>, <a href="http://web.eecs.umich.edu/~weimerw/590/lectures/weimer-gradpl-09.pdf">Lecture 2</a>.</li>
</ol>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#axiomatic-semantics-1"></a></div>
<section id="axiomatic-semantics-1" class="slide level1">
<h1>Axiomatic semantics</h1>
<p>Axiomatic semantics describes semantics of programming language in terms of predicate transformation.</p>
<p>In contrast with operational and denotational semantics, axiomatic semantics is concerned with proving correctness of specific programs.</p>
<p>Operational and denotational semantics are mostly concerned with properties of programming language as a whole.</p>
<p>Axiomatic semantics consists of:</p>
<ul>
<li class="fragment">language of assertions about program state (usually first-order logic, possibly other formal inference system)</li>
<li class="fragment">rules of derivation</li>
</ul>
</section><div><a class="slider-prev" href="#axiomatic-semantics-literature"></a><a class="slider-next" href="#hoare-triples"></a></div>
<section id="hoare-triples" class="slide level1">
<h1>Hoare triples</h1>
<h2 id="a-c-b">{A} c {B}</h2>
<ul>
<li class="fragment">A — precondition (assertion)</li>
<li class="fragment">c — statement of the programming language</li>
<li class="fragment">B — postcondition (assertion)</li>
</ul>
<p>Informal semantics: if A holds immediately before c is executed, then B must hold immediately after c is executed.</p>
</section><div><a class="slider-prev" href="#axiomatic-semantics-1"></a><a class="slider-next" href="#axiomatic-semantics-correctness"></a></div>
<section id="axiomatic-semantics-correctness" class="slide level1">
<h1>Axiomatic semantics correctness</h1>
<p>Correctness of axiomatic semantics is usually defined in terms of programming language operational semantics.</p>
<p>The connection between axiomatic and operational semantics is defined in following way:</p>
<ul>
<li class="fragment">Assertion validity judgement ⊨ — relation between operational semantics configurations and assertions ( σ ⊨ A means "assertion A holds in configuration σ" )</li>
<li class="fragment">Hoare triple semantics (partial): ⊨ { A } c { B } is defined as:
<ul>
<li class="fragment">For all σ ∈ Σ, for all σ' ∈ Σ, if σ ⊨ A and σ (c)⇒ σ', then σ' ⊨ B</li>
</ul></li>
<li class="fragment">Hoare triple semantics (total): ⊨ [ A ] c [ B ] is defined as:
<ul>
<li class="fragment">partial semantics ⊨ { A } c { B }</li>
<li class="fragment">existence of σ'</li>
</ul></li>
</ul>
</section><div><a class="slider-prev" href="#hoare-triples"></a><a class="slider-next" href="#example-imp"></a></div>
<section id="example-imp" class="slide level1">
<h1>Example: Imp'</h1>
<p>Simple imperative language with arithmetical and boolean expressions, assignment, conditional operator and loop.</p>
<p>Abstract syntax (omitting the operator precedence and lexical structure):</p>
<pre class=""><code>Program = Statement "return" VariableName

Statement = VariableName "=" ArithmeticalExpression
| "skip"
| Statement (";" | "\n") Statement
| "if" "(" BooleanExpression ")" "{ " Statement " } else { " Statement " }"
| "while "(" BooleanExpression ")" "{ " Statement  "}"

ArithmeticalExpression = VariableName
| IntegerNumber
| "sqrt" ArithmeticalExpression
| "-" ArithmeticalExpression
| ArithmeticalExpression ("+" | "-" | "*" | "/" | "%") ArithmeticalExpression

BooleanExpression = ArithmeticalExpression ("&lt;" | "&gt;" | "==") ArithmeticalExpression
| "!" BooleanExpression
| BooleanExpression ("&amp;&amp;" | "||" | "^^")</code></pre>
</section><div><a class="slider-prev" href="#axiomatic-semantics-correctness"></a><a class="slider-next" href="#assertion-language"></a></div>
<section id="assertion-language" class="slide level1">
<h1>Assertion language</h1>
<p>First order logic over Imp' boolean expressions:</p>
<p>A = true | false | BooleanExpression | A₁ ∧ A₂ | A₁ ∨ A₂ | A₁ ⇒ A₂ | ∀x.A | ∃x.A | ¬A | e₁ = e₂</p>
<p>Quantification is over variables (x).</p>
</section><div><a class="slider-prev" href="#example-imp"></a><a class="slider-next" href="#assertion-validity"></a></div>
<section id="assertion-validity" class="slide level1">
<h1>Assertion validity</h1>
<p>Definition of relation σ ⊨ A:</p>
<ul>
<li class="fragment">σ ⊨ true</li>
<li class="fragment">σ ⊨ A₁ and σ ⊨ A₂ ⇔ σ ⊨ A₁ ∧ A₂</li>
<li class="fragment">σ ⊨ A₁ ⇒ σ ⊨ A₁ ∨ A₂</li>
<li class="fragment">σ ⊨ A₂ ⇒ σ ⊨ A₁ ∨ A₂</li>
<li class="fragment">σ ⊨ A₁ implies σ ⊨ A₂ ⇔ σ ⊨ A₁ ⇒ A₂</li>
<li class="fragment">∀ n ∈ ℤ σ[x ≔ n] ⊨ A ⇔ σ ⊨ ∀x.A</li>
<li class="fragment">∃ n ∈ ℤ σ[x ≔ n] ⊨ A ⇔ σ ⊨ ∃ x.A</li>
</ul>
</section><div><a class="slider-prev" href="#assertion-language"></a><a class="slider-next" href="#assertion-derivation"></a></div>
<section id="assertion-derivation" class="slide level1">
<h1>Assertion derivation</h1>
<p>To check σ ⊨ A we need to evaluate program in terms of operational semantics (dynamic verification).</p>
<p>To use axiomatic semantics for static verification we need to define formal inference system for Hoare triple derivation.</p>
<p>Derivation judgement ⊢ A on assertions is defined as usual for first-order logic.</p>
<p>Axiomatic semantics is defined as derivation judgement of Hoare triples.</p>
<p>We assume the following rule of consequence ("transitivity" of derivations):</p>
<p><strong>If</strong> ⊢ A' ⇒ A, ⊢ B ⇒ B', ⊢ {A} c {B} <strong>then</strong> ⊢ {A'} c {B'}</p>
</section><div><a class="slider-prev" href="#assertion-validity"></a><a class="slider-next" href="#imp-axiomatic-semantics"></a></div>
<section id="imp-axiomatic-semantics" class="slide level1">
<h1>Imp' axiomatic semantics</h1>
<ol type="1">
<li class="fragment">Skip statement: ⊢ {A} <code>skip</code> {A}</li>
<li class="fragment">Assignment: ⊢ {A[x:=e]} <code>x = e</code> {A}</li>
<li class="fragment">Sequence: <strong>If</strong> ⊢ {A} <code>c₁</code> {B}, ⊢ {B} <code>c₂</code> {C} <strong>then</strong> ⊢ {A} <code>c₁ ; c₂</code> {C}</li>
<li class="fragment">Conditional operator: <strong>If</strong> ⊢ { A ∧ <code>b</code> } <code>c₁</code> {B}, ⊢ { A ∧ ¬<code>b</code> } <code>c₂</code> {B} <strong>then</strong> ⊢ {A} <code>if (b) { c₁ } else { c₂ }</code> {B}</li>
<li class="fragment">Loop: <strong>If</strong> ⊢ { A ∧ <code>b</code> } <code>c</code> {A} <strong>then</strong> ⊢ {A} <code>while (b) { c }</code> {A ∧ ¬<code>b</code>}</li>
</ol>
<p>Derivable rules:</p>
<ul>
<li class="fragment">"forward" axiom for assignment: ⊢ {A} <code>x = e</code> { ∃ x₀. A[ <code>x</code> := x₀] ∧ <code>x</code> = <code>e</code>[<code>x</code> := x₀] }</li>
<li class="fragment">loop invariant: <strong>If</strong> ⊢ A ∧ b ⊢ C, ⊢ {C} <code>c</code> {A}, ⊢ A ∧ ¬ <code>b</code> ⇒ B <strong>then</strong> ⊢ {A} <code>while (b) { c }</code> { B }</li>
</ul>
</section><div><a class="slider-prev" href="#assertion-derivation"></a><a class="slider-next" href="#assignment"></a></div>
<section id="assignment" class="slide level1">
<h1>Assignment</h1>
<ul>
<li class="fragment">aliasing: situation in which single data location in memory can be accessed through different names (aliases) in program.</li>
</ul>
<p>Example (C): <code>int i, *j = &amp;i, *k = &amp;i;</code></p>
<p>In axiomatic semantics the following holds: { true } <code>*j = 5</code> {<code>*i + *j</code> = 10}</p>
</section><div><a class="slider-prev" href="#imp-axiomatic-semantics"></a><a class="slider-next" href="#soundness"></a></div>
<section id="soundness" class="slide level1">
<h1>Soundness</h1>
<p>Soundness for axiomatic semantics (derivable properties are observable):</p>
<h2 id="a-c-b-a-c-b">⊢ {A} c {B} ⇒ ⊨ {A} c {B}</h2>
<p>This statement contains three inductively-defined objects:</p>
<ol type="1">
<li class="fragment">c — program statement</li>
<li class="fragment">⊨ {A} c {B} — operational semantics derivation (sequence of rule applications)</li>
<li class="fragment">⊢ {A} c {B} — axiomatic derivation</li>
</ol>
<p>Obvious proofs by induction on the structure of each of these objects won't work.</p>
<p>Corner cases are <code>while</code> loops and rule of consequence.</p>
</section><div><a class="slider-prev" href="#assignment"></a><a class="slider-next" href="#simultaneous-induction"></a></div>
<section id="simultaneous-induction" class="slide level1">
<h1>Simultaneous induction</h1>
<p>⊢ {A} c {B} ⇒ ⊨ {A} c {B}</p>
<p>Let "&lt;" denote the substructure relation on inductive types (x &lt; y ⇒ x is substructure of y). Elements of an inductive type with substructure relation form partial order.</p>
<p>Let "⊂" denote the lexicographic ordering on tuples of (different) inductive type elements:</p>
<p>(o, a) ⊂ (o', a') ≡ o &lt; o' or (o = o' and a &lt; a')</p>
<p>"⊂" is a well-founded order and we may use it to prove statements by induction with hypothesis "valid for all tuples t ⊂ X" (X is induction step variable).</p>
<p>We can prove soundness for axiomatic semantics by simultaneous induction on the tuple (operational semantics derivation, axiomatic derivation).</p>
</section><div><a class="slider-prev" href="#soundness"></a><a class="slider-next" href="#completeness"></a></div>
<section id="completeness" class="slide level1">
<h1>Completeness</h1>
<p>Axiomatic semantics is complete relative to operational semantics if:</p>
<h2 id="a-c-b-a-c-b-1">⊨ {A} c {B} ⇒ ⊢ {A} c {B}</h2>
</section><div><a class="slider-prev" href="#simultaneous-induction"></a><a class="slider-next" href="#weakest-preconditions"></a></div>
<section id="weakest-preconditions" class="slide level1">
<h1>Weakest preconditions</h1>
<p>(Dijkstra)</p>
<p>To verify that {A} c {B}:</p>
<ol type="1">
<li class="fragment">Find all pre-conditions A': ⊨ {A'} c {B} (Pre(c, B))</li>
<li class="fragment">For one A' ∈ Pre(c, B) prove that ⊢ A ⇒ A'</li>
</ol>
<p>We can define partial order over assertions by means of implication:</p>
<p>A ⊑ A' ⇔ A' ⇒ A</p>
<p>If Pre(c, B) has least upper bound under this order, we call it weakest precondition:</p>
<p>WP(c, B) = lub Pre(c, B)</p>
<p>⊢ A ⇒ WP(c, B)</p>
<p>Special case: <code>while</code> loop, we need to use fixed point theorem (denotational semantics)</p>
</section><div><a class="slider-prev" href="#completeness"></a><a class="slider-next" href="#relative-completeness-expressiveness"></a></div>
<section id="relative-completeness-expressiveness" class="slide level1">
<h1>Relative Completeness: Expressiveness</h1>
<p>We can define weakest precondition in terms of configurations: wp(c, B) = { σ | σ (c)⇒σ' | σ' ⊨ B }.</p>
<p>Then we can say that assertion language is <strong>expressive</strong> if for any command and any postcondition there is a precondition which is valid exactly on weakest precondition in terms of configurations.</p>
</section><div><a class="slider-prev" href="#weakest-preconditions"></a><a class="slider-next" href="#verification-conditions"></a></div>
<section id="verification-conditions" class="slide level1">
<h1>Verification Conditions</h1>
<p>Weakest common preconditions are hard to compute (e.g. <code>while</code> loop).</p>
<p>To make tools for automatic property checking, we can use user input (e.g. loop invariants) to compute "weak enough" preconditions: verification conditions.</p>
</section><div><a class="slider-prev" href="#relative-completeness-expressiveness"></a><a class="slider-next" href="#application-of-axiomatic-semantics"></a></div>
<section id="application-of-axiomatic-semantics" class="slide level1">
<h1>Application of axiomatic semantics</h1>
<ol type="1">
<li class="fragment">Automated verification tools (especially annotation-based).</li>
</ol>
<dl>
<dt class="fragment">2. Code contracts</dt>
<dd class="fragment"><ul>
<li class="fragment">based on the idea of axiomatic semantics, but I'm not aware about any formal proofs of soundness</li>
<li class="fragment">original implementation in Eiffel programming language (e.g. [Section 8](<a href="https://archive.eiffel.com/doc/online/eiffel50/intro/language/tutorial-09.html#pgfId-514761">https://archive.eiffel.com/doc/online/eiffel50/intro/language/tutorial-09.html#pgfId-514761</a>) in Eiffel tutorial) <span class="title-ref">require</span> statement (precondition), <span class="title-ref">ensure</span> statement (postcondition), <span class="title-ref">invariant</span> (class state invariant)</li>
<li class="fragment">probably most well-known implementation is [.NET CodeContracts](<a href="https://github.com/Microsoft/CodeContracts">https://github.com/Microsoft/CodeContracts</a>) (see also [publications](<a href="http://research.microsoft.com/en-us/projects/contracts/">http://research.microsoft.com/en-us/projects/contracts/</a>))</li>
</ul>
</dd>
</dl>
</section><div><a class="slider-prev" href="#verification-conditions"></a><a class="slider-next" href="#codecontracts-examples"></a></div>
<section id="codecontracts-examples" class="slide level1">
<h1>CodeContracts examples</h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="kw">static</span> <span class="dt">void</span> <span class="fu">Main</span><span class="op">(</span><span class="dt">string</span><span class="op">[]</span> args<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">DoRequiresForAll</span><span class="op">(</span><span class="kw">new</span> List<span class="op">&lt;</span><span class="dt">string</span><span class="op">&gt;()</span> <span class="op">{</span><span class="st">"test"</span><span class="op">,</span><span class="kw">null</span><span class="op">,</span><span class="st">"foo"</span><span class="op">});</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> <span class="dt">void</span> <span class="fu">DoRequiresForAll</span><span class="op">(</span>List<span class="op">&lt;</span><span class="dt">string</span><span class="op">&gt;</span> input<span class="op">)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">.</span><span class="fu">Requires</span><span class="op">(</span>Contract<span class="op">.</span><span class="fu">ForAll</span><span class="op">(</span>input<span class="op">,</span> w <span class="op">=&gt;</span> w <span class="op">!=</span> <span class="kw">null</span><span class="op">));</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    input<span class="op">.</span><span class="fu">ForEach</span><span class="op">(</span>Console<span class="op">.</span><span class="fu">WriteLine</span><span class="op">);</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> <span class="dt">string</span> <span class="fu">TrimAfter</span><span class="op">(</span><span class="dt">string</span> value<span class="op">,</span> <span class="dt">string</span> suffix<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">.</span><span class="fu">Requires</span><span class="op">(!</span>String<span class="op">.</span><span class="fu">IsNullOrEmpty</span><span class="op">(</span>suffix<span class="op">));</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">.</span><span class="fu">Requires</span><span class="op">(</span>value <span class="op">!=</span> <span class="kw">null</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">.</span><span class="fu">Ensures</span><span class="op">(</span> <span class="op">!</span>Contract<span class="op">.</span><span class="fu">Result</span><span class="op">&lt;</span><span class="dt">string</span><span class="op">&gt;().</span><span class="fu">EndsWith</span><span class="op">(</span>suffix<span class="op">));</span></span></code></pre></div>
</section><div><a class="slider-prev" href="#application-of-axiomatic-semantics"></a><a class="slider-next" href="#homework-assignments"></a></div>
<section id="homework-assignments" class="slide level1">
<h1>Homework assignments</h1>
<p><strong>Task 11.1</strong> (2*) Write axiomatic semantics for a hypothetical functional programming language based on simply-typed lambda calculus with data types, conditional operator and predefined functions over data types.</p>
<p><strong>Task 11.2</strong> (2*) Write axiomatic semantics for assignment operator in Imp' extended with aliasing operation.</p>
</section><div><a class="slider-prev" href="#codecontracts-examples"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  function handleKeydown(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 33: // Page Up
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 34: // Page Down
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  }
  document.addEventListener("keydown", handleKeydown);
  document.getElementById("flat-view").addEventListener("click", function(e) {
    document.getElementById("main").classList.toggle('slider');
    if (document.getElementById("main").classList.contains('slider')) {
      document.getElementById("container").style="width: 640px;height: 400px;";
      document.addEventListener("keydown", handleKeydown);
    } else {
      document.getElementById("container").style="";
      document.removeEventListener("keydown", handleKeydown);
    }
  })
  </script>
  

</body></html>
