<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="software-and-programming-language-theory" class="slide level1">
<h1>Software and Programming Language Theory</h1>
<h2 id="static-and-dynamic-semantics">Static and dynamic semantics</h2>
<h2 id="scope">Scope</h2>
<h2 id="typing">Typing</h2>
<style>
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
  column-count: 2;
}
.twocolumn div.sourceCode {
  overflow-x: visible;
}
.smallish pre {
  margin: 5px auto;
}
.small { font-size: small !important; }
.smallish { font-size: 0.7em !important; }
.smaller { font-size: 0.8em !important; }
.large { font-size: 1.5em !important; }
.huge { font-size: 2em !important; }
</style>
<p>Course page: <a href="https://maxxk.github.io/programming-languages-2016/" class="uri">https://maxxk.github.io/programming-languages-2016/</a><br>
Contact author: <a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#programming-language-specification"></a></div>
<section id="programming-language-specification" class="slide level1">
<h1>Programming language specification</h1>
<p><img src="graphviz-images/aa5f4656547c5b2a7ce97a49486be6e2a63b8520.svg"></p>
</section><div><a class="slider-prev" href="#software-and-programming-language-theory"></a><a class="slider-next" href="#programming-language-semantics"></a></div>
<section id="programming-language-semantics" class="slide level1">
<h1>Programming language semantics</h1>
<dl>
<dt class="fragment">Static semantics</dt>
<dd class="fragment">static properties of programs, which can be determined without executing them
</dd>
<dd class="fragment">variable bindings (what does variable name correspond to)
</dd>
<dd class="fragment">static type checking (do the expressions satisfy constraints of typing system)
</dd>
<dt class="fragment">Dynamic semantics</dt>
<dd class="fragment">how do we compute the value of expressions, statements, etc.
</dd>
</dl>
</section><div><a class="slider-prev" href="#programming-language-specification"></a><a class="slider-next" href="#naming"></a></div>
<section id="naming" class="slide level1">
<h1>Naming</h1>
<p>In programming languages we usually name entities</p>
<ul>
<li class="fragment">variables</li>
<li class="fragment">function arguments</li>
<li class="fragment">classes</li>
<li class="fragment">modules</li>
</ul>
</section><div><a class="slider-prev" href="#programming-language-semantics"></a><a class="slider-next" href="#binding"></a></div>
<section id="binding" class="slide level1">
<h1>Binding</h1>
Binding is the process of assigning the meaning to a name.<br>

<div class="twocolumn smaller">
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> SimpleDemoClass  
{            
     <span class="kw">public</span> <span class="dt">void</span> GetData&lt;T&gt;(T obj)  
     {  
        <span class="bu">Console</span>.<span class="fu">WriteLine</span>(<span class="st">"INSIDE GetData&lt;T&gt;,"</span>+ obj.<span class="fu">GetType</span>().<span class="fu">Name</span>);  
     }        
     <span class="kw">public</span> <span class="dt">void</span> <span class="fu">GetData</span>(<span class="dt">int</span> x)  
     {  
        <span class="bu">Console</span>.<span class="fu">WriteLine</span>(<span class="st">"INSIDE GetData"</span> + x.<span class="fu">GetType</span>().<span class="fu">Name</span>);  
     }        
     <span class="kw">public</span> <span class="dt">void</span> GetxNextData&lt;T&gt;(T obj)  
     {  
         <span class="fu">GetData</span>(obj);  
     }      
 }  </code></pre></div>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> Program  
{  
      Static <span class="dt">void</span> <span class="fu">Main</span>(string[] args)  
      {    
           SimpleDemoClass sobj = <span class="kw">new</span> <span class="fu">SimpleDemoClass</span>();  
           sobj.<span class="fu">GetData</span>(<span class="st">"data is for testing by-Devesh"</span>);  
           sobj.<span class="fu">GetData</span>(<span class="dv">95</span>);  
           sobj.<span class="fu">GetxNextData</span>(<span class="dv">1234</span>);  
           <span class="bu">Console</span>.<span class="fu">ReadKey</span>();  
       }  
}  </code></pre></div>
</div>
<div class="small">
Example from: <a href="http://www.c-sharpcorner.com/UploadFile/deveshomar/generic-method-overloading-in-C-Sharp/" class="uri">http://www.c-sharpcorner.com/UploadFile/deveshomar/generic-method-overloading-in-C-Sharp/</a>
</div>
</section><div><a class="slider-prev" href="#naming"></a><a class="slider-next" href="#scope-1"></a></div>
<section id="scope-1" class="slide level1">
<h1>Scope</h1>
<p><em>Scope</em> of a binding is a textual region in program in which a binding is active. We may also use term <em>scope</em> to call the region of a program of maximal size in which no bindings are destroyed (masked).</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *a = <span class="st">"QWE123\0"</span>;
<span class="dt">char</span>* fun() {
  dobule a = <span class="dv">0</span>;
  <span class="cf">return</span> a;
}</code></pre></div>
</section><div><a class="slider-prev" href="#binding"></a><a class="slider-next" href="#dynamic-scope"></a></div>
<section id="dynamic-scope" class="slide level1">
<h1>Dynamic scope</h1>
<div class="twocolumn">
<p>Some languages (like ECMAScript/JavaScript or some kinds of LISP) have a concept of the <em>dynamic scoping</em>. Binding of identifiers occurs at run-time.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
<span class="kw">function</span> <span class="at">f</span>() <span class="op">{</span>
  <span class="kw">var</span> b <span class="op">=</span> a<span class="op">;</span>
  <span class="cf">with</span> (<span class="op">{</span><span class="dt">a</span><span class="op">:</span> <span class="dv">1</span><span class="op">}</span>) <span class="op">{</span>
    b <span class="op">+=</span> a<span class="op">;</span>
  <span class="op">}</span>
  <span class="cf">return</span> b<span class="op">;</span> <span class="co">// b = 1</span>
<span class="op">}</span></code></pre></div>
<p><code>this</code> in object-oriented language may be seen as either an implicit argument to a function or as a way of introducing a dynamic scope.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">g</span>() <span class="op">{</span>
  <span class="cf">return</span> <span class="kw">this</span>.<span class="at">x</span><span class="op">;</span>
<span class="op">}</span>
<span class="kw">var</span> A <span class="op">=</span> <span class="op">{</span> <span class="dt">x</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> g <span class="op">}</span>
<span class="kw">var</span> B <span class="op">=</span> <span class="op">{</span> <span class="dt">x</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> g <span class="op">}</span>
<span class="va">A</span>.<span class="at">g</span>() <span class="co">// returns 0</span>
<span class="va">B</span>.<span class="at">g</span>() <span class="co">// returns 1</span>
<span class="at">g</span>() <span class="co">// returns 2</span></code></pre></div>
</div>
</section><div><a class="slider-prev" href="#scope-1"></a><a class="slider-next" href="#name-overloading"></a></div>
<section id="name-overloading" class="slide level1">
<h1>Name overloading</h1>
<div class="twocolumn smallish">
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T mul(<span class="dt">int</span> i, <span class="dt">int</span> j)
{
   <span class="co">// If you get a compile error, it's because you did not use</span>
   <span class="co">// one of the authorized template specializations</span>
   <span class="at">const</span> <span class="dt">int</span> k = <span class="dv">25</span> ; k = <span class="dv">36</span> ;
}
<span class="kw">template</span>&lt;&gt;
<span class="dt">int</span> mul&lt;<span class="dt">int</span>&gt;(<span class="dt">int</span> i, <span class="dt">int</span> j)
{
   <span class="cf">return</span> i * j ;
}

<span class="kw">template</span>&lt;&gt;
<span class="bu">std::</span>string mul&lt;<span class="bu">std::</span>string&gt;(<span class="dt">int</span> i, <span class="dt">int</span> j)
{
   <span class="cf">return</span> <span class="bu">std::</span>string(j, <span class="kw">static_cast</span>&lt;<span class="dt">char</span>&gt;(i)) ;
}</code></pre></div>
<p>If the language supports name overloading, the same identifier in the same place may have a different meaning depending on some external information (like typing). Usually in imperative languages name overloading is restricted to functions names.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> mul(<span class="dt">int</span> i, <span class="dt">int</span> j) { <span class="cf">return</span> i*j; }
<span class="bu">std::</span>string mul(<span class="dt">char</span> c, <span class="dt">int</span> n) { <span class="cf">return</span> <span class="bu">std::</span>string(n, c); }

<span class="dt">int</span> n = mul(<span class="dv">6</span>, <span class="dv">3</span>); <span class="co">// n = 18</span>
<span class="bu">std::</span>string s = mul(<span class="kw">static_cast</span>&lt;<span class="dt">char</span>&gt;(<span class="dv">6</span>), <span class="dv">2</span>); <span class="co">// s = "110"</span>
<span class="dt">int</span> n = mul&lt;<span class="dt">int</span>&gt;(<span class="dv">6</span>, <span class="dv">3</span>); <span class="co">// n = 18</span>
<span class="bu">std::</span>string s = mul&lt;<span class="bu">std::</span>string&gt;(<span class="dv">54</span>, <span class="dv">2</span>); <span class="co">// s = "110110"</span>
<span class="dt">short</span> n2 = mul&lt;<span class="dt">short</span>&gt;(<span class="dv">6</span>, <span class="dv">3</span>); <span class="co">// error: assignment of read-only variable ‘k’</span></code></pre></div>
Languages supporting function overloading: C++, C#<br>
Languages not supporting function overloading: Haskell, ECMAScript, C (but C11 has the <code>_Generic</code> keyword: <a href="http://stackoverflow.com/a/25026358" class="uri">http://stackoverflow.com/a/25026358</a>)
</div>
<div class="small">
Example from: <a href="http://stackoverflow.com/questions/226144/overload-a-c-function-according-to-the-return-value" class="uri">http://stackoverflow.com/questions/226144/overload-a-c-function-according-to-the-return-value</a>
</div>
</section><div><a class="slider-prev" href="#dynamic-scope"></a><a class="slider-next" href="#static-semantics-representation"></a></div>
<section id="static-semantics-representation" class="slide level1">
<h1>Static semantics representation</h1>
<p>Let us return to the topic of formal mechanized analysis of programs.</p>
<p><img src="graphviz-images/ed002a3970835e74b75f748296f96716059b7048.svg"></p>
<p>Syntax is a transformation from <code>String</code> to <abbr title="Abstract Syntax Tree"><code>AST</code></abbr>. Static semantics, in the same way, is a transformation from AST to AST with variable bindings information. How would we store this information?</p>
<p>Easier approach: generate unique names and store scope in parallel.</p>
<p>AST+Bindings = Σ (ast : AST /[Id := ℕ]) . (scope : Map&lt;ℕ, AST&gt; ) . (p : ∀ { id : ℕ } ∈ ast, id ∈ scope).</p>
<div class="small">
Example at: Vasenin V. A., Krivchikov M. A. Ecma-335 static formal semantics // Programming and Computer Software. — 2012. — Vol. 38, no. 4. — P. 183–188. <a href="http://dx.doi.org/10.1134/S0361768812040056" class="uri">http://dx.doi.org/10.1134/S0361768812040056</a>
</div>
</section><div><a class="slider-prev" href="#name-overloading"></a><a class="slider-next" href="#higher-order-abstract-syntax"></a></div>
<section id="higher-order-abstract-syntax" class="slide level1">
<h1>Higher order abstract syntax</h1>
— the technique to capture the variable binding in abstract syntax tree (Miller, 1987; Phenning, 1988).<br>

<div class="twocolumn">
<p>Abstract syntax:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> var = <span class="dt">string</span>
<span class="kw">type</span> typ =
  | Bool
  | Arrow <span class="kw">of</span> typ * typ
<span class="kw">type</span> <span class="dt">exp</span> =
  | Var <span class="kw">of</span> var
  | True
  | False
  | App <span class="kw">of</span> <span class="dt">exp</span> * <span class="dt">exp</span>
  | Abs <span class="kw">of</span> var * <span class="dt">exp</span></code></pre></div>
Higher-order syntax captures the name binding:<br>

<div>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> <span class="dt">exp</span> =
  | True
  | False
  | App <span class="kw">of</span> <span class="dt">exp</span> * <span class="dt">exp</span>
  | Abs <span class="kw">of</span> <span class="dt">exp</span> -&gt; <span class="dt">exp</span></code></pre></div>
</div>
<p>Parametrized Higher-order syntax captures the types of variables:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 't var
<span class="kw">type</span> 't <span class="dt">exp</span> =
    | Var : 't var -&gt; 't <span class="dt">exp</span>
    | True : <span class="dt">bool</span> <span class="dt">exp</span>
    | False : <span class="dt">bool</span> <span class="dt">exp</span>
    | App : ('d -&gt; 'r) <span class="dt">exp</span> * 'd <span class="dt">exp</span> -&gt; 'r <span class="dt">exp</span>
    | Abs : ('d var -&gt; 'r <span class="dt">exp</span>) -&gt; ('d -&gt; 'r) <span class="dt">exp</span></code></pre></div>
<a href="http://adam.chlipala.net/papers/PhoasICFP08/" class="uri">http://adam.chlipala.net/papers/PhoasICFP08/</a>
</div>
</section><div><a class="slider-prev" href="#static-semantics-representation"></a><a class="slider-next" href="#ornaments"></a></div>
<section id="ornaments" class="slide level1">
<h1>Ornaments</h1>
<p>Conor McBride. «Ornamental Algebras, Algebraic Ornaments»</p>
<p>One base data type defines the induction structure, basic constructors:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Nat <span class="kw">where</span>
  <span class="dv">0</span> <span class="ot">:</span> Nat
  succ <span class="ot">:</span> Nat <span class="ot">→</span> Nat</code></pre></div>
<p>Then we place an additional data (ornament) to the leaves of the induction structure:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> List [A <span class="ot">:</span> Set] from Nat <span class="kw">where</span>
   List<span class="ot">_</span>A ← nil
    <span class="ot">|</span> cons [a <span class="ot">:</span> A] <span class="ot">(</span>as <span class="ot">:</span> List<span class="ot">_</span>A<span class="ot">)</span>

<span class="kw">data</span> Vec [A <span class="ot">:</span> Set] from Nat <span class="kw">where</span>
  Vec<span class="ot">_</span>A n ← nil [q <span class="ot">:</span> n ≡ 0]
     <span class="ot">|</span> cons [n' <span class="ot">:</span> Nat][ q <span class="ot">:</span> n <span class="ot">=</span> succ n' ] <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">(</span>vs <span class="ot">:</span> Vec<span class="ot">_</span>A n<span class="ot">)</span></code></pre></div>
<div class="small">
<a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/LitOrn.pdf" class="uri">https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/LitOrn.pdf</a><br>
<a href="http://arxiv.org/pdf/1201.4801.pdf" class="uri">http://arxiv.org/pdf/1201.4801.pdf</a>
</div>
</section><div><a class="slider-prev" href="#higher-order-abstract-syntax"></a><a class="slider-next" href="#recursion"></a></div>
<section id="recursion" class="slide level1">
<h1>Recursion</h1>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> A { B b; }
<span class="kw">class</span> B { A a; }</code></pre></div>
<p>Suppose we started translating <abbr title="Abstract Syntax Tree">AST</abbr> to static semantics. Before we process second line and see that <code>B</code> is a class, what is the static semantics of <code>B</code> at the first line?</p>
<p>Approach: fixed point (works for classical Domain Theory, doesn't work well in a constructive setting).</p>
<p>N.S. Papaspyrou. Formal semantics of the C Programming Language (PhD thesis).</p>
</section><div><a class="slider-prev" href="#ornaments"></a><a class="slider-next" href="#homework-assignments"></a></div>
<section id="homework-assignments" class="slide level1">
<h1>Homework assignments</h1>
<p><strong>Task 5.1.</strong> ** Implement a translator from simply-typed lambda calculus <abbr title="Abstract Syntax Tree">AST</abbr> to <abbr title="Higher-Order Abstract Syntax">HOAS</abbr> in Haskell or any other language of your choice (except the original OCaml) which is expressive enough to represent HOAS.</p>
<p><strong>Task 5.2.</strong> *** Implement a translator from simply-typed lambda calculus <abbr title="Abstract Syntax Tree">AST</abbr> to <abbr title="Parametrized Higher-Order Abstract Syntax">PHOAS</abbr> in Haskell or any other language of your choice (except the original OCaml) which is expressive enough to represent PHOAS.</p>
</section><div><a class="slider-prev" href="#recursion"></a><a class="slider-next" href="#project"></a></div>
<section id="project" class="slide level1">
<h1>Project</h1>
<p><strong>Project Step 4.</strong> Implement a static formal semantics for your programming language (in Agda or Coq). Choose one of the following approaches.</p>
<ul>
<li class="fragment"><strong>Project Step 4a.</strong> * Assign the unique identifiers (e.g. natural numbers) to each bindable identifier leaf in the AST and create the mapping between the unique identifiers and static semantics subtrees.</li>
<li class="fragment"><strong>Project Step 4b.</strong> ** Use Higher-Order Abstract Syntax.</li>
</ul>
</section><div><a class="slider-prev" href="#homework-assignments"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#software-and-programming-language-theory" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>
